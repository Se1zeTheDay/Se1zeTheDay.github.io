<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-Hashmap</title>
    <url>/2020/05/27/Java%20Hashmap/</url>
    <content><![CDATA[<h1 id="Java-Hashmap常用用法"><a href="#Java-Hashmap常用用法" class="headerlink" title="Java-Hashmap常用用法"></a>Java-Hashmap常用用法</h1><p>//定义map，K和V为类，不允许基本类型<br>HashMap &lt;K, V&gt; map = new HashMap&lt;K, V&gt;();</p>
<p>//设置K键的值为V，即通过哈希函数计算出V = H(K)<br>map.put(K, V); </p>
<p>//获取K键的值,返回值为V类型<br>map.get(K); </p>
<p>//删除K键的值，返回的是V<br>map.remove(K);</p>
<p>//判断是否有K键的值<br>boolean containsKey(K);</p>
<p>//判断是否有值为V<br>boolean containsValue(V);</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM经典数塔问题</title>
    <url>/2020/04/24/ACM%E7%BB%8F%E5%85%B8%E6%95%B0%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="ACM经典数塔问题"><a href="#ACM经典数塔问题" class="headerlink" title="ACM经典数塔问题"></a>ACM经典数塔问题</h1><p>此题为动态规划法的简单训练题。  </p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们假设数组 p[i][j] 来表示数塔中的数，m[i][j] 表示从数塔顶端开始到第 i 行第 j 列的最大路径长度。<br>由题意可知，每一步只能沿左斜线向下或右斜线向下，那么很容易得到<br><strong>m[i][j] = max{m[i-1][j-1], m[i-1][j]} + p[i][j]</strong><br>注意不要忘记边界条件，即 <strong>j = 1</strong> 或 <strong>j = i</strong> 时，<br><strong>m[i][j] = m[i-1][j] + p[i][j]</strong></p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50</span></span><br><span class="line"><span class="keyword">int</span> m[M][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> p[M][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mathTower</span><span class="params">(<span class="keyword">int</span> (*m)[M], <span class="keyword">int</span> (*p)[M],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">1</span> || j == i)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i][j] = m[i<span class="number">-1</span>][j] + p[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m[i][j] = <span class="built_in">max</span>(m[i<span class="number">-1</span>][j<span class="number">-1</span>], m[i<span class="number">-1</span>][j]) + p[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mathTower(m,p,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    k = m[n][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( m[n][j] &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            k = m[n][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对数塔问题的优化"><a href="#对数塔问题的优化" class="headerlink" title="对数塔问题的优化"></a>对数塔问题的优化</h2><p>由以上分析可知，我们在解决数塔问题时采用的是由顶向下的路线，我们可以反过来<strong>自下而上</strong>考虑。<br>对于问题规模 n = 2 的数塔，共有两条路径。<br>对于问题规模 n = 3 的数塔，我们可以将其看作两个规模为 n = 2的数塔加上塔顶。<br>以此类推。。。<br>此时数塔问题可以用一个式子来刻画<br><strong>m[i][j] += max(m[i+1][j], m[i+1][j+1])</strong><br>m[i][j]数组既保存了数塔中的数，又在动态规划过程中逐步形成最优解，即<strong>m[1][1]</strong></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Stack</title>
    <url>/2020/05/31/Java%20Stack/</url>
    <content><![CDATA[<h1 id="Java-Stack常用用法"><a href="#Java-Stack常用用法" class="headerlink" title="Java Stack常用用法"></a>Java Stack常用用法</h1><h2 id="Stack的基本使用"><a href="#Stack的基本使用" class="headerlink" title="Stack的基本使用"></a>Stack的基本使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>Stack&lt;&gt; stack=new Stack&lt;&gt;();</strong></p>
<h3 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h3><p><strong>stack.empty();</strong></p>
<h3 id="取栈顶值（不出栈）"><a href="#取栈顶值（不出栈）" class="headerlink" title="取栈顶值（不出栈）"></a>取栈顶值（不出栈）</h3><p><strong>stack.peek();</strong></p>
<h3 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h3><p><strong>stack.push(Object);</strong></p>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p><strong>stack.pop();</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-List</title>
    <url>/2020/06/01/Java%20List/</url>
    <content><![CDATA[<h1 id="Java-List基本用法"><a href="#Java-List基本用法" class="headerlink" title="Java List基本用法"></a>Java List基本用法</h1><p>//List初始化<br>List&lt;&gt; list = new ArrayList&lt;&gt;();</p>
<p>//添加元素方法：<br>list.add(e);<br>　　<br>//获取方法：<br>list.get(index);<br>　　<br>//按照索引删除：<br>ist.remove(index);</p>
<p>//按照按照元素内容删除:　　<br>list.remove(Object o);</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中String,StringBuilder与StringBuffer的区别</title>
    <url>/2020/06/30/Java%20String%E3%80%81StringBuffer%E4%B8%8EStringBuilder/</url>
    <content><![CDATA[<h1 id="Java中String-StringBuilder与StringBuffer的区别"><a href="#Java中String-StringBuilder与StringBuffer的区别" class="headerlink" title="Java中String,StringBuilder与StringBuffer的区别"></a>Java中String,StringBuilder与StringBuffer的区别</h1><h2 id="运算速度比较-通常情况下-StringBuilder-gt-StringBuffer-gt-String"><a href="#运算速度比较-通常情况下-StringBuilder-gt-StringBuffer-gt-String" class="headerlink" title="运算速度比较(通常情况下) StringBuilder &gt; StringBuffer &gt; String"></a>运算速度比较(通常情况下) StringBuilder &gt; StringBuffer &gt; String</h2><p>String是final类不能被继承且为字符串常量，而StringBuilder和StringBuffer均为字符串变量。String对象一旦创建便不可更改，而后两者是可更改的，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个null，通过append方法向StringBuffer和StringBuilder中赋值。<br>请看如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = str + <span class="string">"de"</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>上述代码先创建一个String对象str，并赋值abc给str，然后运行到第三行，JVM会再创建一个新的str对象，并将原有str的值和de加起来再赋值给新的str。而第一个创建的str对象被JVM的垃圾回收机制（GC）回收掉。所以str实际上并没有被更改，即String对象一旦创建就不可更改。所以Java中对String对象进行的操作实际上是一个不断创建并回收对象的过程，因此在运行速度上很慢。</p>
<p>而StringBuilder和StringBuffer的对象是变量，对变量的操作是直接对该对象就行更改，因此不会进行反复的创建和回收。所以在运行速度上比较快。</p>
<p>但也有如下情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span> + <span class="string">"de"</span>;</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p><strong>上述代码中String的操作速度反而要比StringBuilder快，这是因为在JVM眼里，第1行的代码操作和下列代码是完全一样的，所以很快。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abcde"</span>;</span><br></pre></td></tr></table></figure>
<p>但如下的代码写法形式速度会很慢，JVM会不断地创建和回收对象来进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"de"</span>;</span><br><span class="line">String str = str1 + str2;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="StringBuilder（非线程安全）"><a href="#StringBuilder（非线程安全）" class="headerlink" title="StringBuilder（非线程安全）"></a>StringBuilder（非线程安全）</h3><p>而StringBuilder的方法没有该关键字修饰，所以不能保证线程安全性。是JDK1.5新增的，该类提供一个与StringBuffer兼容的 API，但不能保证同步，所以在性能上较高。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="StringBuffer（线程安全的）"><a href="#StringBuffer（线程安全的）" class="headerlink" title="StringBuffer（线程安全的）"></a>StringBuffer（线程安全的）</h3><p>StringBuffer中大部分方法由synchronized关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是线程安全的。类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String：适用于少量的字符串操作。</p>
<p>StringBuilder：适用于单线程下在字符串缓冲区进行大量操作。</p>
<p>StringBuffer：适用于多线程下在字符串缓冲区进行大量操作。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TSP问题</title>
    <url>/2020/05/02/TSP%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="TSP问题"><a href="#TSP问题" class="headerlink" title="TSP问题"></a>TSP问题</h1><h2 id="TSP问题的简介"><a href="#TSP问题的简介" class="headerlink" title="TSP问题的简介"></a>TSP问题的简介</h2><p>TSP问题即旅行商问题，该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最短路径</p>
<h2 id="建立问题模型"><a href="#建立问题模型" class="headerlink" title="建立问题模型"></a>建立问题模型</h2><p>用图来表示该问题的模型，设图 G = (V, E),顶点代表城市，边的权值代表城市之间的路径长度。<br>用二维数组 g[i][j]来表示该图，g[i][j]表示从点 i 到点 j 的权值，若 i 与 j 不相邻，那么g[i][j] = -1，若相邻则表示权值。<br>数组x[i]用来表示解向量。</p>
<h2 id="问题的解空间"><a href="#问题的解空间" class="headerlink" title="问题的解空间"></a>问题的解空间</h2><p>该问题显然解空间为排列树，大小为n！</p>
<h2 id="剪枝函数"><a href="#剪枝函数" class="headerlink" title="剪枝函数"></a>剪枝函数</h2><p>显然城市之间首先应该相邻，即 <strong>g[x[t-1]][x[t]] != -1</strong>，其次最后一个城市与第一个城市也得有路径相连，即 <strong>g[x[n]][x[1]] != -1</strong>。<br>设 cp 表示当前走过的路径的长度，bestp 表示以前找到的最短路径的长度。显然，若 cp &gt; bestp，那么没有必要在这条路线上继续搜索下去。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>一开始自己写，有一说一，我是真的菜，分析了一下原因在于回溯后状态应该变为原来的状态，而且若不采用m数组，那么状态无法恢复，而我忘记了这件事，改好后的代码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//g数组表示图G (V, E)</span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">5</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//bestp表示最优路径值</span></span><br><span class="line"><span class="keyword">int</span> bestp = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//x[5]数组暂存最优解</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//cp表示当前路径之和</span></span><br><span class="line"><span class="keyword">int</span> cp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//m数组表示每个点是否被选过，1说明被选过，0则没有</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//k数组最终存放最优解</span></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//递归用回溯法解决tsp问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TSP</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理边界问题即最后一个结点回到第一个结点的问题</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">5</span> &amp;&amp; g[x[t - <span class="number">1</span>]][x[<span class="number">1</span>]] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp + g[x[t - <span class="number">1</span>]][x[<span class="number">1</span>]] &lt;= bestp)</span><br><span class="line">        &#123;</span><br><span class="line">            bestp = cp + g[x[t - <span class="number">1</span>]][x[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                k[i] = x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x[t] = i; </span><br><span class="line">            <span class="comment">//标记已被访问过的结点</span></span><br><span class="line">            m[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//满足约束条件</span></span><br><span class="line">            <span class="keyword">if</span> ((g[x[t - <span class="number">1</span>]][x[t]] &gt;= <span class="number">0</span>) &amp;&amp; (cp + g[x[t - <span class="number">1</span>]][x[t]] &lt; bestp))</span><br><span class="line">            &#123;</span><br><span class="line">                cp += g[x[t - <span class="number">1</span>]][x[t]];</span><br><span class="line">                TSP(t + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                cp -= g[x[t - <span class="number">1</span>]][x[t]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            m[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出最优值与最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bestp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, k[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSP(<span class="number">2</span>);</span><br><span class="line">    Display(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码改进-参照书本"><a href="#代码改进-参照书本" class="headerlink" title="代码改进(参照书本)"></a>代码改进(参照书本)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 101</span></span><br><span class="line"><span class="keyword">int</span> MAXINT = <span class="number">9999999</span>;  <span class="comment">//无穷大表示不相邻</span></span><br><span class="line"><span class="keyword">int</span> bestx[NUM];</span><br><span class="line"><span class="keyword">int</span> g[NUM][NUM];</span><br><span class="line"><span class="keyword">int</span> x[NUM];</span><br><span class="line"><span class="keyword">int</span> bestc = MAXINT;</span><br><span class="line"><span class="keyword">int</span> cl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travelingREC</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (t == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[x[n - <span class="number">1</span>]][x[n]] &lt; MAXINT &amp;&amp; g[x[n]][x[<span class="number">1</span>]] &lt; MAXINT &amp;&amp; cl + g[x[n - <span class="number">1</span>]][x[n]] + g[x[n]][x[<span class="number">1</span>]] &lt; bestc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[i] = x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            bestc = cl + g[x[n - <span class="number">1</span>]][x[n]] + g[x[n]][x[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试解</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= n; i++)   <span class="comment">//从t开始避免重复</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[x[t - <span class="number">1</span>]][x[i]] &lt; MAXINT &amp;&amp; cl + g[x[t - <span class="number">1</span>]][x[i]] &lt; bestc)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;x[t], &amp;x[i]);</span><br><span class="line">                cl = cl + g[x[t - <span class="number">1</span>]][x[t]];</span><br><span class="line">                travelingREC(t + <span class="number">1</span>);</span><br><span class="line">                cl = cl - g[x[t - <span class="number">1</span>]][x[t]];</span><br><span class="line">                swap(&amp;x[t], &amp;x[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">4</span>;</span><br><span class="line">    m = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">2</span>] = g[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">4</span>] = g[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">3</span>] = g[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    g[<span class="number">2</span>][<span class="number">3</span>] = g[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    g[<span class="number">2</span>][<span class="number">4</span>] = g[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">    g[<span class="number">3</span>][<span class="number">4</span>] = g[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//初始化解向量顺序，顺序不唯一但不能全为 0 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    travelingREC(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最短路径为: %d\n解向量为: "</span>, bestc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>, bestx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-01</title>
    <url>/2020/05/27/leetcode-01/</url>
    <content><![CDATA[<p>#两数之和<br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<h2 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h2><p>最近用 java 语言写来巩固一下 java，忘得差不多了，很烦。</p>
<p>这题没有说数组是有序的，那么首先显然是暴力法。暴力法就不用说了，看完题解之后发现还有采用哈希查找的方式，不得不复习了一下数据结构。</p>
<p>这里直接给出解法：</p>
<h3 id="两遍哈希表"><a href="#两遍哈希表" class="headerlink" title="两遍哈希表"></a>两遍哈希表</h3><p>第一遍将数组元素放入哈希表，第二遍通过target - nums[i]的键值搜索哈希表得到值并返回数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一遍哈希表"><a href="#一遍哈希表" class="headerlink" title="一遍哈希表"></a>一遍哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一个问题例如像{2,2,3,4,5}这样的数组，target为4<br>那么采用哈希表存储将会丢失key为2，value为1的元素，但从解法来看不影响。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-02</title>
    <url>/2020/05/28/leetcode-02/</url>
    <content><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>这题整体思路十分清晰，首先是本位和等于（两个数据加上的地位的进位）mod 10<br>然后有几点不能忘记：<br>一个是两个数的位数不一定相等，所以当对应位数加完时应判断两个指针是否都为空。<br>另一个是最高位的进位不能丢失，第一次提交时我就丢失了。</p>
<p>下面给出代码(有一说一，内存占的有点多）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p = l1;</span><br><span class="line">        ListNode q = l2;</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode t = l3;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode s = <span class="keyword">new</span> ListNode((p.val + q.val + carry) % <span class="number">10</span>);</span><br><span class="line">            t.next = s;</span><br><span class="line">            carry = (p.val + q.val + carry) / <span class="number">10</span>;</span><br><span class="line">            t = t.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q == <span class="keyword">null</span> &amp;&amp; p != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             ListNode s = <span class="keyword">new</span> ListNode((p.val + carry) % <span class="number">10</span>);</span><br><span class="line">             t.next = s;</span><br><span class="line">             carry = (p.val + carry) / <span class="number">10</span>;</span><br><span class="line">             t = t.next;</span><br><span class="line">             p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             ListNode s = <span class="keyword">new</span> ListNode((q.val + carry) % <span class="number">10</span>);</span><br><span class="line">             t.next = s;</span><br><span class="line">             carry = (q.val + carry) / <span class="number">10</span>;</span><br><span class="line">             t = t.next;</span><br><span class="line">             q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode s = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">            t.next = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Solving Equations</title>
    <url>/2020/05/04/Solving%20Equations/</url>
    <content><![CDATA[<h1 id="Solving-Equations"><a href="#Solving-Equations" class="headerlink" title="Solving Equations"></a>Solving Equations</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>任给一个等式，等式中不含有任何算术运算符，只含有数字，括号与等号；等式右边的计算没有优先规则，从左到右进行计算，有括号先计算括号内的；只能在等式中填入加，减和乘号使得等式成立。<br>例如 18 = 7 (5 3) 2，一种可能的结果为 18 = 7 + (5 - 3) * 2;<br>又例如 5 = 3 3,显然不为等式。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>每个运算符的位置都能放加，减和乘，显然解空间为完全 3 叉树。<br>我们建立一个a数组用来保存输入的等式原值，iLeft变量代表等式左值，用指针遍历a数组，记下a数组中需要添加运算符的位置，并记在op数组中，同时略过a数组中的等号及等号左边的数，将等号右边的式子略过空格并标记运算符位置存到b数组中，接着开始递归回溯，得到解。</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT -1            <span class="comment">//左括号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT -2           <span class="comment">//右括号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL -3             <span class="comment">//*号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD -4             <span class="comment">//+号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUB -5             <span class="comment">//-号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP -6              <span class="comment">//该位置有运算符</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONE -10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];        <span class="comment">//原始的等式数据</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100</span>];         <span class="comment">//伪表达式</span></span><br><span class="line"><span class="keyword">int</span> best[<span class="number">100</span>];      <span class="comment">//答案</span></span><br><span class="line"><span class="keyword">int</span> op[<span class="number">30</span>];         <span class="comment">//运算符在数组b中的位置</span></span><br><span class="line"><span class="keyword">int</span> bn;             <span class="comment">//数组b的项数</span></span><br><span class="line"><span class="keyword">int</span> iLeft;          <span class="comment">//等式左边的数</span></span><br><span class="line"><span class="keyword">int</span> apos;           <span class="comment">//数组a的位置指针</span></span><br><span class="line"><span class="keyword">int</span> bpos;           <span class="comment">//数组b的位置指针</span></span><br><span class="line"><span class="keyword">int</span> opos;           <span class="comment">//操作符数组的位置指针</span></span><br><span class="line"><span class="keyword">int</span> possible;       <span class="comment">//是否有解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bracket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">space</span><span class="params">()</span>  <span class="comment">//跳过数字之间的空格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a[apos] &amp;&amp; (a[apos] == <span class="string">' '</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        apos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> <span class="comment">//计算右边表达式值的算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//右边第一个数</span></span><br><span class="line">    <span class="keyword">int</span> sum = bracket();</span><br><span class="line">    <span class="keyword">while</span> (b[bpos] == MUL || b[bpos] == ADD || b[bpos] == SUB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> operation = b[bpos++];   <span class="comment">//取出运算符</span></span><br><span class="line">        <span class="keyword">int</span> ret = bracket();         <span class="comment">//取出下一个数</span></span><br><span class="line">        <span class="comment">//根据运算符进行运算</span></span><br><span class="line">        <span class="keyword">switch</span> (operation)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> MUL: sum *= ret; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADD: sum += ret; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUB: sum -= ret; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bracket</span><span class="params">()</span>  <span class="comment">//括号的判断及数值计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">if</span> (b[bpos] == LEFT)</span><br><span class="line">    &#123;</span><br><span class="line">        bpos++;</span><br><span class="line">        sum = compute();  <span class="comment">//计算括号里面的值</span></span><br><span class="line">        bpos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum = b[bpos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> dep)</span> <span class="comment">//形参dep表示第几个运算符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (possible)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//得到答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">if</span> (dep == opos)      <span class="comment">//所有运算符构造完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        bpos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> iRight = compute(); </span><br><span class="line">        <span class="keyword">if</span> (iRight == iLeft)  </span><br><span class="line">        &#123;</span><br><span class="line">            possible = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                best[i] = b[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前结点的3个孩子结点，分别使用+，-和*运算符进行构造</span></span><br><span class="line">    b[op[dep]] = MUL; backtrack(dep + <span class="number">1</span>);</span><br><span class="line">    b[op[dep]] = ADD; backtrack(dep + <span class="number">1</span>);</span><br><span class="line">    b[op[dep]] = SUB; backtrack(dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d = "</span>, iLeft);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (q[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD: <span class="built_in">printf</span>(<span class="string">"+"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MUL: <span class="built_in">printf</span>(<span class="string">"*"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUB: <span class="built_in">printf</span>(<span class="string">"-"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT: <span class="built_in">printf</span>(<span class="string">"("</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT: <span class="built_in">printf</span>(<span class="string">")"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OP: <span class="built_in">printf</span>(<span class="string">"?"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"%d"</span>, q[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iCase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (gets_s(a) &amp;&amp; <span class="built_in">strchr</span>(a, <span class="string">'='</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        possible = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">90</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] = NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        apos = <span class="number">0</span>;</span><br><span class="line">        sscanf_s(a, <span class="string">"%d"</span>, &amp;iLeft);</span><br><span class="line">        <span class="keyword">while</span> (a[apos] &amp;&amp; <span class="built_in">isdigit</span>(a[apos]))</span><br><span class="line">        &#123;</span><br><span class="line">            apos++;</span><br><span class="line">        &#125;</span><br><span class="line">        space();</span><br><span class="line">        apos++;</span><br><span class="line">        bn = <span class="number">0</span>;</span><br><span class="line">        opos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (space(), a[apos])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[apos] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[bn++] = LEFT;</span><br><span class="line">                apos++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[apos] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[bn++] = RIGHT;</span><br><span class="line">                apos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sscanf_s(a + apos, <span class="string">"%d"</span>, &amp;b[bn++]);</span><br><span class="line">                <span class="keyword">while</span> (a[apos] &amp;&amp; <span class="built_in">isdigit</span>(a[apos])) apos++;</span><br><span class="line">            &#125;</span><br><span class="line">            space();</span><br><span class="line">            <span class="comment">//如果不是结尾和')'，则说明bn指向的地方有一个运算符</span></span><br><span class="line">            <span class="keyword">if</span> (a[apos] &amp;&amp; a[apos] != <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                op[opos++] = bn;    <span class="comment">//记下运算符的位置</span></span><br><span class="line">                b[bn++] = OP;       <span class="comment">//在数组b中标记此处为运算符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Equation #%d:\n"</span>, ++iCase);</span><br><span class="line">        <span class="keyword">if</span> (bn == <span class="number">1</span> &amp;&amp; iLeft == b[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d = %d\n"</span>, iLeft, iLeft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bn == <span class="number">0</span> || !possible)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(best);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-04</title>
    <url>/2020/05/23/leetcode-04/</url>
    <content><![CDATA[<h1 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a>寻找两个有序数组的中位数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。<br>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先看时间复杂度，为 O(log(m + n))，那么很明显不能用二路归并法先将数组排好序，这样一来时间复杂度就来到了O(m + n)。<br>这里我们采用递归法<br>首先我们需要了解中位数的作用，在统计中，中位数被用来<br><strong>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</strong><br>如果理解了中位数的划分作用，我们就很接近答案了。<br>首先，让我们在任一位置 i 将 A 划分成两个部分：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br></pre></td></tr></table></figure>
<p>由于 A 中有 m 个元素，所以我们有 m + 1 种划分的方法（i = 0 ~ m）。<br>所以有：<br>length(left_A) = i, length(right_A) = m - i.<br>当 i = 0 时，left_A 为空集，而当 i = m 时，right_A 为空集。<br>采用同样的方式，我们在任一位置 j 将 B 划分成两个部分：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure>
<p>将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。再把这两个集合分别命名为 left_part 和 right_part：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure>
<p>如果我们可以确认：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, length(left_part) &#x3D; length(right_part)</span><br><span class="line">2, max(left_part) ≤ min(right_part)</span><br></pre></td></tr></table></figure>
<p>那么我们已经将{A，B}中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：<br><strong>median = [max(left_part)+min(right_part)] / 2</strong><br>要确保这两个条件，我们只需要保证：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,i + j &#x3D; m - i + n - j（或：m - i + n - j + 1(m + n为奇数情况下））</span><br><span class="line">如果 n ≥ m，只需要使 i &#x3D; 0 ∼ m, j&#x3D; (m + n + 1) &#x2F; 2 − i  </span><br><span class="line">2,B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]  </span><br><span class="line">ps： n ≥ m 是为了确保 j 不为负数，因为 i &#x3D; 0 ~ m。</span><br></pre></td></tr></table></figure>
<p>所以，我们需要做的是：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在[0, m]中搜素并找到目标对象 i，使得：  </span><br><span class="line">B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]</span><br><span class="line">其中 j&#x3D; (m + n + 1) &#x2F; 2 − i</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-hard</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-102</title>
    <url>/2020/07/05/leetcode-102/</url>
    <content><![CDATA[<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br>通过次数154,115提交次数244,497</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个题一看就知道是用队列的了，但是有个问题，就是你需要把不同层数的结点分开来保存，那么这里我想的是设置一个键值对，记下当前结点的深度，接着将它add到list中，当结点深度不同时，就将list add进ans中，然后清空list。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        q.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(root, <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Pair&lt;TreeNode, Integer&gt; cur = q.poll();</span><br><span class="line">            TreeNode cur_node = cur.getKey();</span><br><span class="line">            <span class="keyword">int</span> cur_depth = cur.getValue();</span><br><span class="line">            <span class="keyword">if</span> (cur_depth != temp)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.add(templist);</span><br><span class="line">                templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            templist.add(cur_node.val);</span><br><span class="line">            temp = cur_depth;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur_node.left != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_node.right != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(templist);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>一开始我还沾沾自喜的，看了官方的题解后，发现根本不需要记下深度，这里有个对广度优先搜索方法的修改，就是每一次出队的时候不只是出队一个元素，而是出队所有元素，那么出队的所有元素一定是在树中的同一层，这个可以证明。<br>算法思想如下：</p>
<img src="/2020/07/05/leetcode-102/102_1.jpg" class title="改进的bfs算法">

<p>算法正确性的证明：</p>
<img src="/2020/07/05/leetcode-102/102_2.jpg" class title="算法证明">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立队列并让根节点入队</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//取出队列中所有元素，根据证明这些元素处于同一层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//处理当前元素</span></span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//添加下一层元素</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-104</title>
    <url>/2020/07/04/leetcode-104/</url>
    <content><![CDATA[<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题不难，总的来说两个方法，深度优先遍历和广度优先遍历</p>
<h3 id="代码量最少的方法-分治法"><a href="#代码量最少的方法-分治法" class="headerlink" title="代码量最少的方法:分治法"></a>代码量最少的方法:分治法</h3><p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left_height = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候才能写出这样的代码啊，唉</p>
<h3 id="深度优先遍历法"><a href="#深度优先遍历法" class="headerlink" title="深度优先遍历法"></a>深度优先遍历法</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxdepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> maxdepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            maxdepth = Math.max(maxdepth, count);</span><br><span class="line">            depth(root.left);</span><br><span class="line">            depth(root.right);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历法"><a href="#广度优先遍历法" class="headerlink" title="广度优先遍历法"></a>广度优先遍历法</h3><p>这里采用队列实现。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(root, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Pair&lt;TreeNode, Integer&gt; current = queue.poll();</span><br><span class="line">            TreeNode cur_root = current.getKey();</span><br><span class="line">            <span class="keyword">int</span> cur_depth = current.getValue();</span><br><span class="line">            depth = Math.max(cur_depth, depth);</span><br><span class="line">            <span class="keyword">if</span> (cur_root.left != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(cur_root.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_root.right != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(cur_root.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-101</title>
    <url>/2020/07/04/leetcode-101/</url>
    <content><![CDATA[<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3</p>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题我想的是给左子树来一次先序遍历，再给右子树来一次后序遍历，接着判断两次遍历的结果是否相等，如果相等说明就是对称二叉树，但是这样做达不到锻炼的效果。</p>
<h3 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h3><p>我真的要崩溃了，都知道怎么判断是不是对称，可是我怎么就想不到去设置两个指针，让他们同步往下走，一个往左一个就往右。题解的代码一如既往地简洁，我的心情也一如既往地沉重。</p>
<p>在递归传给下一层时，两个指针都要改变，那么可以把两个指针作为函数的参数。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：迭代"><a href="#法二：迭代" class="headerlink" title="法二：迭代"></a>法二：迭代</h3><p>引入队列是将递归程序改为迭代程序的常用方法，其实我觉得应该是这样的，在递归地某一层中如果要对很多对象进行操作，而且这些对象在不同的递归层数中的数目不同并且有规律，那么可以用队列来实现递归转迭代的方法，否则不需要队列也能解决，这只是我的直觉，实际问题还是要实际分析。</p>
<p>初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode cur_left = root;</span><br><span class="line">        TreeNode cur_right = root;</span><br><span class="line">        </span><br><span class="line">        q.add(cur_left);</span><br><span class="line">        q.add(cur_right);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            cur_left = q.poll();</span><br><span class="line">            cur_right = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur_left == <span class="keyword">null</span> &amp;&amp; cur_right == <span class="keyword">null</span>) <span class="keyword">continue</span>;;</span><br><span class="line">            <span class="keyword">if</span> (cur_left == <span class="keyword">null</span> || cur_right == <span class="keyword">null</span> || cur_left.val != cur_right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            q.add(cur_left.left);</span><br><span class="line">            q.add(cur_right.right);</span><br><span class="line">            </span><br><span class="line">            q.add(cur_left.right);</span><br><span class="line">            q.add(cur_right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>希望自己总结的递归的经验是正确的，也希望自己能够一直坚持地努力下去。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-116</title>
    <url>/2020/06/04/leetcode-116/</url>
    <content><![CDATA[<h1 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题上来看了没多久就知道是用递归，难点在于如何处理右结点的next指向，感觉不是很难，嘿嘿，这里就直接给出代码啦。</p>
<p>法一：递归，深度搜索</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若结点左孩子不为空</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//处理右子结点的next指向</span></span><br><span class="line">                <span class="keyword">if</span> (root.next == <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                     root.right.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    root.right.next = root.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理左子结点的next指向</span></span><br><span class="line">                root.left.next = root.right;</span><br><span class="line">                <span class="comment">//递归处理左子结点</span></span><br><span class="line">                connect(root.left);</span><br><span class="line">                <span class="comment">//递归处理右子结点</span></span><br><span class="line">                connect(root.right);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：采用队列，每一次的for循环对应树一层的结点（相同深度），在peek队列元素时将元素连接起来。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;Node&gt; Q = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//将根结点添加至队列中</span></span><br><span class="line">        Q.add(root);</span><br><span class="line">        <span class="comment">//每一次进入while循环都是新一层的结点</span></span><br><span class="line">        <span class="keyword">while</span> (Q.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记下当前深度树的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> size = Q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node node = Q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>( i &lt; size -<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    node.next = Q.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//向队列中添加下一层的元素</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-108</title>
    <url>/2020/07/05/leetcode-108/</url>
    <content><![CDATA[<h1 id="将有序数组转化为二叉搜索树"><a href="#将有序数组转化为二叉搜索树" class="headerlink" title="将有序数组转化为二叉搜索树"></a>将有序数组转化为二叉搜索树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>      0<br>     / <br>   -3   9<br>   /   /<br> -10  5<br>通过次数94,694提交次数129,204</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>芜湖，终于又自己写出递归了，本来没啥思路，下楼恰了个中饭不知怎么想到了二分法，哈哈。</p>
<p>具体思路如下：<br>因为构造出的二叉搜索树一定是高度平衡的，所以考虑将题目所给的有序数组二分，这样左边就用来构造左子树，右边构造右子树，那么同理，左边那部分继续二分，。。。，这样一次类推，就有一种递归的思想在里面，每一层的操作都是相同的。</p>
<p>递归分为递归体和递归出口，那么这个题目的递归出口就在区间左右相等的情况，也就是只剩下一个元素时。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">createBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">            root.left = createBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">            root.right = createBST(nums,mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h2><p>其实left = right的情况也可以合并到 &lt; 情况中，因为都要建立一个新结点并且left = right时mid就和left还有right都相等。</p>
<p>那么这样一来代码就可以改成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">createBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = createBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = createBST(nums,mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-125</title>
    <url>/2020/06/30/leetcode-125/</url>
    <content><![CDATA[<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>示例 2:</p>
<p>输入: “race a car”<br>输出: false</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>看到判断回文串一般是用双指针，然后双指针遍历的代码一般都是这么写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; restrictions)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; restrictions)</span><br><span class="line">    &#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">do</span> what;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这道题的话这里有几个函数是写好的可以直接用，我之前是不知道的。</p>
<p>一个是toLowerCase(),可以直接把字符串转换成小写的。<br>还有一个函数是真的不知道，其实我有点惊讶还有这样的函数，就是Character类下的isLetterOrDigit()函数，他可判断一个字符是数字还是字母。</p>
<p>这些都知道之后，剩下的就好解决了。</p>
<p>先介绍直接双指针判断是否为回文串法。</p>
<h3 id="法一：双指针直接判断"><a href="#法一：双指针直接判断" class="headerlink" title="法一：双指针直接判断"></a>法一：双指针直接判断</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：先筛选后判断"><a href="#法二：先筛选后判断" class="headerlink" title="法二：先筛选后判断"></a>法二：先筛选后判断</h3><p>先将字符串中的除数字与字母以外的字符全部去掉，随后判断剩下的字符串是否为回文串即可。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sgood = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class="line">                sgood.append(Character.toLowerCase(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = sgood.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后贴上自己写的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s= s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(s.charAt(i)) &amp;&amp; Character.isLetterOrDigit(s.charAt(j)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(i)))</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(j)))</span><br><span class="line">                &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-122</title>
    <url>/2020/06/21/leetcode-122/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:</p>
<p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这一题其实很简单，方法二方法三我都想到了，但是做复杂了，我发现了，数组的题目在数组内操作是很繁琐的，看了题解之后发现很多这样的题目都是新建变量来保存数组里的东西，我们直接看题解吧。</p>
<p>先把自己的代码贴了：有一说一，又多又烂:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; buy = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Integer&gt; sell = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k0;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (k &lt; prices.length &amp;&amp; prices[k] == prices[k - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == prices.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prices[k - <span class="number">1</span>] &lt; prices[k])</span><br><span class="line">        &#123;</span><br><span class="line">            buy.add(prices[k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; prices.length - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k0 = j;</span><br><span class="line">            <span class="keyword">while</span> (k0 &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[k0 + <span class="number">1</span>] == prices[k0])</span><br><span class="line">            &#123;</span><br><span class="line">                k0++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k0 &lt; prices.length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[k0] &lt; prices[j - <span class="number">1</span>] &amp;&amp; prices[k0] &lt; prices[k0 + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    buy.add(prices[k0]);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (prices[k0] &gt; prices[j - <span class="number">1</span>] &amp;&amp; prices[k0] &gt; prices[k0 + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    sell.add(prices[k0]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[j - <span class="number">1</span>] &lt; prices[prices.length - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    sell.add(prices[prices.length - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buy.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (sell.get(i) - buy.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><img src="/2020/06/21/leetcode-122/122_1.jpg" class title="题解1">
<p>个人觉得关键的地方就是vally与peak两个变量记下了当前的峰与谷，这样一来遍历一次数组就可以得到最大利润。<br>写下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vally = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> peak = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>]) </span><br><span class="line">                i++;</span><br><span class="line">            vally = prices[i];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            peak = prices[i];</span><br><span class="line">            maxProfit += peak - vally;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/06/21/leetcode-122/122_2.jpg" class title="题解2">
<p>这个方法其实我一开始就想到了，但是没有仔细想下去，简单来说就是把交易拆成单次的就比如 3 - 1 = (2 - 1) + (3 - 2)。唉，每次都把问题复杂化。<br>代码十分简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-141</title>
    <url>/2020/07/08/leetcode-141/</url>
    <content><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：<br>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>很容易想到用哈希表标记结点，有重复的就是有环，这个就不多说了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Map&lt;ListNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(p)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> map.put(p, <span class="number">1</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度O-1-算法"><a href="#空间复杂度O-1-算法" class="headerlink" title="空间复杂度O(1)算法"></a>空间复杂度O(1)算法</h2><p>果不其然，还是用的双指针法，但是为什么我就想不到呢</p>
<p>思路来源于追及问题，在运动场上跑圈时跑的快和跑的慢的赛跑，总有一天跑的快的会赶上跑的慢的。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-133</title>
    <url>/2020/06/04/leetcode-133/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap &lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(node))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node cloneNode = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList());</span><br><span class="line">        </span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Node neightbor : node.neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neightbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-14</title>
    <url>/2020/07/03/leetcode-14/</url>
    <content><![CDATA[<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p>
<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题最先想到的肯定是暴力法，也就是纵向扫描。我想的是比字串，思路差不多，但是是最差的办法，没想到一道简单的题目也有这么多花样。</p>
<h3 id="法一：纵向比较"><a href="#法一：纵向比较" class="headerlink" title="法一：纵向比较"></a>法一：纵向比较</h3><p>纵向扫描就是一次遍历每个字符串，来更新最长的公共前缀。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环逐一比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没有出现上述情况，也就是</span></span><br><span class="line"><span class="comment">        strs[1..j]的所有字符串长度都大于等于strs[0].length()</span></span><br><span class="line"><span class="comment">        并且前面的字符都相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：横向比较"><a href="#法二：横向比较" class="headerlink" title="法二：横向比较"></a>法二：横向比较</h3><p>这个方法就要一点算法的基础了，没有积累是想不太到这样的方法的。</p>
<p>我们用一个公式来表示：</p>
<img src="/2020/07/03/leetcode-14/14_1.jpg" class title="最长公共前缀公式">

<p>通俗一点来说就是strs中所有串的最长公共前缀肯定是任意两个串的最长公共前缀的子串。</p>
<p>那么有了这一点，我们就可以先取两个串求出最长公共前缀，接着遍历strs数组中剩下的串，若有不同则删除最长公共前缀中的元素，如果在遍历结束之前这个前缀的长度已经为0，说明不存在最长公共前缀，否则返回这个前缀。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix = findCommonStr(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用函数使代码更清晰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findCommonStr</span><span class="params">(String prefix, String str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(prefix.length(), str.length());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length &amp;&amp; prefix.charAt(i) == str.charAt(i))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法三：分治算法"><a href="#法三：分治算法" class="headerlink" title="法三：分治算法"></a>法三：分治算法</h3><img src="/2020/07/03/leetcode-14/14_2.jpg" class title="分治算法">

<p>这里我想谈谈分治算法的思路与代码的写法，一般分治算法分到最小规模时，便是递归的出口，分治算法和递归比较像，解决完子问题后，一般原问题的解就是子问题的解的合并或是其他操作。</p>
<p>像这里这个问题我们将问题分到最小规模，也就是只有一个串的时候，那么合并的操作明显就是对这两个串求最大公共前缀，再和这一层的其他问题的解进行合并,<br>也就是小问题的解能帮助解决大问题。 </p>
<p>那么代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Chip(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分解函数，将大问题分解成小问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Chip</span><span class="params">(String[] strs, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> strs[left];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            String leftstr = Chip(strs, left, mid);</span><br><span class="line">            String rightstr = Chip(strs,mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">return</span> findCommonStr(leftstr, rightstr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分解成小问题后的解决方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findCommonStr</span><span class="params">(String leftstr, String rightstr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(leftstr.length(), rightstr.length());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length &amp;&amp; leftstr.charAt(i) == rightstr.charAt(i))</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftstr.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法四：二分查找法"><a href="#法四：二分查找法" class="headerlink" title="法四：二分查找法"></a>法四：二分查找法</h3><p>具体思路我贴个图吧</p>
<img src="/2020/07/03/leetcode-14/14_3.jpg" class title="二分查找法">
<p>这里注意isCommonStr()函数判断的是0~ mid - 1是否是公共串，因此之后将mid给left。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到串数组中长度最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> minlength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            minlength = Math.min(minlength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分法进行查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = minlength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left + <span class="number">1</span>) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (isCommonStr(strs, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断0~mid - 1是否和其他串中该位置的子串相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonStr</span><span class="params">(String[] strs, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(j) != strs[i].charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-136</title>
    <url>/2020/06/25/leetcode-136/</url>
    <content><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个题目要求时间复杂度为O(n),说实话我一点思路都没有，解法真的难想。</p>
<p>如果没有空间复杂度O(1)的限制，那还有挺多方法。</p>
<p>这里简单列举几个：</p>
<h3 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h3><p>1，使用集合(set)存储数字,遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，否则在集合中删除该元素，那么最后集合中剩下的一个元素就是只出现一次的元素。<br>2，集合取差值得到只出现一次的元素，遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，否则加入另外一个集合，最后将两个集合做差值得到改元素。</p>
<h3 id="使用哈希表"><a href="#使用哈希表" class="headerlink" title="使用哈希表"></a>使用哈希表</h3><p>使用哈希表存储每个数字和该数字出现的次数，遍历哈希表即得到只出现一次的数字。</p>
<h3 id="此题符合题意的解-位运算"><a href="#此题符合题意的解-位运算" class="headerlink" title="此题符合题意的解:位运算"></a>此题符合题意的解:位运算</h3><p>首先说明位运算的三个性质：<br>1，任何数和0做异或运算，结果仍然为原来的数，即a ⊕ 0 = a。<br>2，任何数和其自身做异或运算，结果仍然是0，即a ⊕ a = 0。<br>3，异或运算满足交换律和结合律，即 a ⊕ b ⊕ a = b ⊕ a ⊕ a = b ⊕ (a ⊕ a) = b ⊕ 0 = b。</p>
<p>那么接下来就很容易了，只需要将数组中的所有元素进行异或运算，剩下来的那个元素就是只出现一次的元素。</p>
<img src="/2020/06/25/leetcode-136/136_1.jpg" class title="位运算(异或运算)">
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-19</title>
    <url>/2020/05/28/leetcode-19/</url>
    <content><![CDATA[<h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>刚看到这个题，第一眼肯定会想到将链表遍历一边，记下节点数，然后反推正数的序号，接着删除。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       ListNode next;</span><br><span class="line">       ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">       ListNode p = head;</span><br><span class="line">       <span class="keyword">while</span> (p != <span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           m++;</span><br><span class="line">           p = p.next;</span><br><span class="line">       &#125;</span><br><span class="line">       p = head;</span><br><span class="line">       <span class="keyword">if</span> (n == m)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m-n-<span class="number">1</span>; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         p.next = p.next.next;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶分析"><a href="#进阶分析" class="headerlink" title="进阶分析"></a>进阶分析</h2><p>事实上，可以优化上述算法从而实现只对链表进行一次遍历。<br><strong>我们可以使用两个指针而不是一个。第一个指针从列表的开头向前移动 n + 1 步，而第二个指针将从列表的开头出发。<br>即两个指针被 n 个结点分开，接着我们通过让两个指针同时移动来保持他们之间的间距，直到第一个指针到达最后一个结点。</strong>  </p>
<p>注意：<br>1，我们需要建立哑节点，否则该规则不满足<br>2，建立哑节点之后的边界情况（N = M 或 N = 1）易证均满足</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">           ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">           dummy.next = head;</span><br><span class="line">           ListNode first = dummy;</span><br><span class="line">           ListNode second = dummy;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               first = first.next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (first != <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               first = first.next;</span><br><span class="line">               second = second.next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="来自大佬的代码"><a href="#来自大佬的代码" class="headerlink" title="来自大佬的代码"></a>来自大佬的代码</h2><h3 id="采用哈希表存储结点数-即键值为索引，值为节点地址"><a href="#采用哈希表存储结点数-即键值为索引，值为节点地址" class="headerlink" title="采用哈希表存储结点数,即键值为索引，值为节点地址"></a>采用哈希表存储结点数,即键值为索引，值为节点地址</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        Map&lt;Integer, ListNode&gt; m = <span class="keyword">new</span> Hashmap&lt;Integer, ListNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//存储到哈希表中</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.put(index++, temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = m.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.get(size - <span class="number">1</span>).next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == size)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m.get(size - n).next = m.get(size - n + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采用递归法"><a href="#采用递归法" class="headerlink" title="采用递归法"></a>采用递归法</h3><p>利用递归执行顺序的特点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        head.next = removeNthFromEnd(head.next, n);</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">if</span> (n == cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-189</title>
    <url>/2020/06/24/leetcode-189/</url>
    <content><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题首先想到的肯定是暴力法，每次数组每个元素都向后移动一个元素，总共移动k次。<br>暴力法不仔细说了，需要两个变量来保存移动时的元素</p>
<p>这里想重点说的是一下两个方法：</p>
<h3 id="1，环状替换法"><a href="#1，环状替换法" class="headerlink" title="1，环状替换法"></a>1，环状替换法</h3><p>这个方法我是想到的，其实挺容易想到的，但是一开始想到的时候忽略了k % n == 0的情况，也就是在一圈回来之后会回到原地，那么此时我们可以得到一个内循环中止条件，也就是此时的下标与开始时的下标相同，并且让其他元素也遍历到。用count来保存遍历过的元素数量，当count与nums.length - 1相等时，说明所有元素均已遍历到，可以结束外循环。说起来挺容易的，但是代码不好写，题解的代码很妙。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">int</span> element = nums[index];</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">            temp = nums[(index + k) % nums.length];</span><br><span class="line">            nums[(index + k) % nums.length] = element;</span><br><span class="line">            element = temp;</span><br><span class="line">            index = (index + k) % nums.length;</span><br><span class="line">            count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != index);</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，反转法"><a href="#2，反转法" class="headerlink" title="2，反转法"></a>2，反转法</h3><p>这个方法我觉得是最妙的，但是不容易想到，估计也是观察出来的，我发现自己每次刷题的时候都挺浮躁的，注意力不是很集中。</p>
<p>首先，当我们旋转数组k次时，尾部的k%n个元素会被移动到数组的头部，剩下的元素会被向后移动。</p>
<p>具体算法举例如下图：</p>
<img src="/2020/06/24/leetcode-189/189_1.jpg" class title="反转法">

<p>接着写下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-206</title>
    <url>/2020/07/06/leetcode-206/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题我想用递归写的，想了很久，后来能递归出来但是头结点无法保存，看了题解原来就差一点点，递归还是得多练啊。</p>
<p>题解核心部分的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我自己的核心部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    p.next = head;</span><br><span class="line">    p = p.next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种代码区别在于我的返回后无法找到头结点了，分析一下造成这样的原因，其实可以看出来要想返回之后头结点保存好，那么p肯定是不能改变的，在递归的每一层中，p为当前头结点，head为当前需要插入在后面的结点，光靠head其实也够了，因此只需改变head就可以了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-198</title>
    <url>/2020/05/30/leetcode-198/</url>
    <content><![CDATA[<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2:</p>
<p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>本题第一次拿到手的时候，我想当然了，觉得很简单，以为只要偷奇数个或是偶数个就可以解决问题。<br>后来仔细一想不对啊，这样肯定不行，思前想后没有办法，偷看了一下题目的标签，好家伙，动态规划。<br>想到在算法课上学过这个，我就仔细回忆了一下，最后还是想出来了嘿嘿，快乐。</p>
<p>我自己定义了一个visited[]数组记录是否偷过，m[i]数组表示从第一间屋子到第 i 间屋子偷到的最大值。<br>如果第 i 间屋子未被偷过，那么可以偷，即 m[i + 1] = m[i] + p[i + 1], p[i]表示价值<br>如果第 i 间屋子偷过，那么肯定不能偷第 i + 1 间,即有 m[i + 1] = max(m[i], m[i - 1] + p[i + 1])</p>
<p>再加上边界情况的考虑，写出代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">            <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>  (nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                m[<span class="number">1</span>] = nums[<span class="number">0</span>] ;</span><br><span class="line">                v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m[<span class="number">1</span>] = nums[<span class="number">1</span>] ;</span><br><span class="line">                v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length - <span class="number">2</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span> (v[i] != <span class="number">1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   m[i + <span class="number">1</span>] = m[i] + nums[i + <span class="number">1</span>];</span><br><span class="line">                   v[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (m[i] &gt;= m[i - <span class="number">1</span>] + nums[i + <span class="number">1</span>])</span><br><span class="line">                   &#123;</span><br><span class="line">                       m[i + <span class="number">1</span>] = m[i];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       m[i + <span class="number">1</span>] = m[i - <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">                       v[i] = <span class="number">0</span>;</span><br><span class="line">                       v[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m[nums.length - <span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>其实仔细一想，会发现其实没必要判断第 i 间房屋是否被偷过，也就是说<strong>对于每一间房屋只有偷与不偷的说法</strong>，直接写出状态转移方程：</p>
<p>m[i + 1] = max(m[i], m[i - 1] + p[i + 1])，i &gt;= 1 即可</p>
<p>改进的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-20</title>
    <url>/2020/05/31/leetcode-20/</url>
    <content><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true</p>
<p>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true</p>
<p>示例 3:</p>
<p>输入: “(]”<br>输出: false</p>
<p>示例 4:</p>
<p>输入: “([)]”<br>输出: false</p>
<p>示例 5:</p>
<p>输入: “{[]}”<br>输出: true</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个题很明显的是使用栈，在看完java栈的用法后直接写了代码，但是因为逻辑不清晰而纠结了很久，我觉得以后写代码应该要先把逻辑理清，大概写出伪代码，不能想到什么写什么，然后再去改。</p>
<p>一开始没想到用哈希表来储存关键字导致代码量偏多。唉，好烦啊。</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">         Map&lt;Character, Character&gt; m = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">         m.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">         m.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">         m.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//为左括号则进栈</span></span><br><span class="line">             <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span> || s.charAt(i) == <span class="string">'['</span> || s.charAt(i) == <span class="string">'&#123;'</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 stack.push(s.charAt(i));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             否则就是右括号，进行判断栈是否为空，栈顶元素与右括号是否相等，相等则pop,  </span></span><br><span class="line"><span class="comment">             有一条件不满足则返回false</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == m.get(s.charAt(i)))</span><br><span class="line">             &#123;</span><br><span class="line">                stack.pop();     </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> stack.isEmpty(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-207</title>
    <url>/2020/06/03/leetcode-207/</url>
    <content><![CDATA[<h1 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br>示例 2:</p>
<p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先题目的意思简单来说就是有向图中不能出现回路</p>
<p>这道题我虽然不太会，但是能学到很多东西，这里采用拓扑排序加dfs判断是否有回路的算法。</p>
<p>首先得建立邻接表，然后用dfs算法遍历图的邻接表，去判断图中是否有回路(dfs算法肯定不能直接判断只能用来遍历，这里加了个flag数组，即相当于以前的visited[]数组，不同的是，数组中0代表当前正在访问的节点，1代表已访问过，-1代表还未访问)</p>
<p>然后就是代码的问题，为了对问题有更深的理解，我觉得还是先写下大致的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(adj, flag, i)</span><br><span class="line">建立邻接表</span><br><span class="line">初始化flag数组为-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> (i指向邻接表的某一行)    <span class="comment">//以i为起点</span></span><br><span class="line">    flag[i] &lt;- <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (j遍历邻接表的第i行)</span><br><span class="line">    <span class="keyword">if</span>  flag[j] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(!dfs(adj, flag, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> <span class="comment">//说明有回路</span></span><br><span class="line">    flag[i] &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>实际Java代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List &lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        adj.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : prerequisites)</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(adj, flag, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adj, <span class="keyword">int</span>[] flag, <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        flag[v0] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : adj.get(v0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(!dfs(adj, flag, i))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[v0] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-21</title>
    <url>/2020/05/27/leetcode-21/</url>
    <content><![CDATA[<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h2 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h2><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>看到这题应该很容易想到双指针法，这里就不多说了，直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">           ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode p = head;</span><br><span class="line">           <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (l1.val &lt;= l2.val)</span><br><span class="line">               &#123;</span><br><span class="line">                   p.next = l1;</span><br><span class="line">                   l1 = l1.next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   p.next = l2;</span><br><span class="line">                   l2 = l2.next;</span><br><span class="line">               &#125;</span><br><span class="line">                   p = p.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               p.next = l2;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               p.next = l1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归真是一看就会，一写就废，还是得多练习啊。</p>
<p>这个题其实就是比较两个元素谁小，小的话就接上去，那么从递归的角度来讲，假如list1[0] &lt;= list2[0]，那么可以让list1剩下的部分于list2继续比较，谁更小就接到list[0]后边</p>
<p>所谓的递归出口，就是当l1或是l2为空时，返回剩下的元素。</p>
<p>写成式子就是<br>list1[0] + merge(list1[1..n],list2) 当list1[0] &lt;= list2[0]时<br>list2[0] + merge(list1,list2[1..n]) otherwise</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> l2;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> l1;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (l1.val &lt;= l2.val)</span><br><span class="line">          &#123;</span><br><span class="line">              l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">              <span class="keyword">return</span> l1;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">              <span class="keyword">return</span> l2;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-234</title>
    <url>/2020/07/08/leetcode-234/</url>
    <content><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题我想的是将链表先反转，在判断和原来的相不相等。</p>
<h3 id="法一：先翻转再比较"><a href="#法一：先翻转再比较" class="headerlink" title="法一：先翻转再比较"></a>法一：先翻转再比较</h3><p>但是一看题解后发现可以只翻转一半，再判断其中的一半与另一半是否相等，主要想不到双指针能这么用，就是快指针一次走两步，慢指针一次走1步，那当快指针走到底时，慢指针一定在链表的一半位置，这样就可以将后一半进行翻转，在与前一半进行比较。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode half = findHalf(head);</span><br><span class="line">        ListNode halfReverse = reverseList(half.next);</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = halfReverse;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half.next = reverseList(halfReverse);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findHalf</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="法二：递归采用双指针"><a href="#法二：递归采用双指针" class="headerlink" title="法二：递归采用双指针"></a>法二：递归采用双指针</h3><p>这个算法设计的很好，先利用的递归的特性将curentNode指针指向链表最后一个元素，然后利用递归的回溯进行后面指针的回溯，接着前面的指针也同步往后移，就可以比较了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode frontNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        frontNode = head;</span><br><span class="line">        <span class="keyword">return</span> recursivelyCheck(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode currentNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!recursivelyCheck(currentNode.next)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.val != frontNode.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            frontNode = frontNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-237</title>
    <url>/2020/07/06/leetcode-237/</url>
    <content><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明:</p>
<p>链表至少包含两个节点。<br>链表中所有节点的值都是唯一的。<br>给定的节点为非末尾节点并且一定是链表中的一个有效节点。<br>不要从你的函数中返回任何结果。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>刚开始看到这个题目的时候还以为给的参数就是头节点，后来测试一看不是的，给的参数就是要删除的节点，但是平时我们在链表中删除一个节点都是将这个节点的后置节点连接到节点的前置节点上，而这里并没有给前置节点，因此我想的是将后面的值都往前移，最后只要令倒数第二个节点的next值为null就可以了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode pre = node;</span><br><span class="line">        ListNode p = node.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre.val = p.val;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.val = p.val;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解优化"><a href="#题解优化" class="headerlink" title="题解优化"></a>题解优化</h2><p>看了官方题解后，感觉这题变成脑筋急转弯了，我怎么就没有多想一步，其实将节点后面的值给该节点之后，我们可以将问题转化为删除node.next节点，那么node为其前置节点，node.next.next为其后置节点，这样问题就转化为了普通的删除单链表节点问题，两行代码解决问题。</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-217</title>
    <url>/2020/06/25/leetcode-217/</url>
    <content><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p>
<p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题拿上来以为有什么奇技淫巧，最后一看题解并没有。</p>
<p>这道题是为了让我们了解一些基本的数据结构的概念：<br>循环不变式，线性查找，排序与哈希表</p>
<p>接下来一边介绍方法，一边来介绍这些概念。</p>
<h3 id="法一：朴素线性查找【超时】"><a href="#法一：朴素线性查找【超时】" class="headerlink" title="法一：朴素线性查找【超时】"></a>法一：朴素线性查找【超时】</h3><p>对于一个有 n 个整数的数组，一共有 n(n - 1) / 2 对整数，我们逐一对每一对整数进行检测查看是否相同。</p>
<p>那么很明显的，若我们从数组尾部开始向前检测，对于第 i 个整数nums[i]，我们对前 i - 1 个元素进行查找是否有重复值。如果找到，那么返回true，否则返回false。</p>
<p>下面介绍循环不变式的概念：<br><strong>循环不变式是指在每次迭代前和后均保持不变的性质</strong><br>我们可以根据这个性质来进行编程，那么在这个题目中循环不变式就是：<br><strong>在每次搜索开始时，搜索过的元素中不会有重复的整数。</strong></p>
<p>写下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == nums[i]) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法时间复杂度为O(n^2),在leetcode中超时。</p>
<h3 id="法二：排序法"><a href="#法二：排序法" class="headerlink" title="法二：排序法"></a>法二：排序法</h3><p>将数组排完序后，很容易想到，重复的元素一定是相邻的，所以只需要判断相邻的元素是否存在相等的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法三：哈希表"><a href="#法三：哈希表" class="headerlink" title="法三：哈希表"></a>法三：哈希表</h3><p>对我而言，我觉得法三我要重点掌握，因为总是想不到用哈希表，肯定是对这个数据结构不够熟悉导致的</p>
<p>这个题目用到的搜索和插入操作比较多，而哈希表进行此类操作的时候正好比较快。</p>
<p>对于数组的普通查找时间复杂度为O(n),二分查找时间复杂度为O(logn)，但哈希表查找只需O(1),插入操作也同理。</p>
<img src="/2020/06/25/leetcode-217/217_1.jpg" class title="哈希表">
<p>写下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> Hashset&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-210</title>
    <url>/2020/06/05/leetcode-210/</url>
    <content><![CDATA[<h1 id="课程表II"><a href="#课程表II" class="headerlink" title="课程表II"></a>课程表II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: [0,1]<br>解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。<br>示例 2:</p>
<p>输入: 4, [[1,0],[2,0],[3,1],[3,2]]<br>输出: [0,1,2,3] or [0,2,1,3]<br>解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p>
<p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p>
<p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p>
<p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0代表当前正在访问，1代表已访问过，-1代表还未访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        List &lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        List &lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        adj.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : prerequisites)</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(adj, flag, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adj, <span class="keyword">int</span>[] flag, <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        flag[v0] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : adj.get(v0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i] == -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(!dfs(adj, flag, i))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[v0] = <span class="number">1</span>;</span><br><span class="line">        ans.add(v0);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>这里直接写伪代码吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">建立邻接表；</span><br><span class="line">建立入度表；</span><br><span class="line">入度为<span class="number">0</span>的点入队；</span><br><span class="line"><span class="keyword">while</span>（队列不为空）</span><br><span class="line">    出队；</span><br><span class="line">    添加至拓扑排序数组；</span><br><span class="line">    课程数--；</span><br><span class="line">    入读表变化；</span><br><span class="line">    与出队元素相邻的入度为<span class="number">0</span>的点入队；</span><br><span class="line"><span class="keyword">if</span>（课程数为<span class="number">0</span>） 说明没有回路，<span class="keyword">return</span> 拓扑排序数组;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> [];</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">        <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] cp: prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">            indegrees[cp[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">            ans.add(temp);</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (Integer j: adj.get(temp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indegrees[j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-24</title>
    <url>/2020/05/29/leetcode-24/</url>
    <content><![CDATA[<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题一开始我没啥好的思路，就觉得应该搞两个指针，然后交换节点，但是这样一来就有个问题，<br>设pre = head，p = head.next，接着交换，那到下一次交换pre和p的顺序就反过来了，也就是说奇偶不同，<br>这样情况就比较复杂。</p>
<p>那我就开始想，能不能简化过程呢。有一说一，这道题我想出来还是很开心的，毕竟第一次自己分析并写出了递归的代码，  虽然中间因为想不到发了很久的呆，哈哈哈。</p>
<p>采用递归的思想，首先不看边界情况，也就是链表为奇数个，或者直接为空。<br>我们让pre = head，p = head.next，那么交换后，想要让剩下来的链表继续交换就得把剩下的链表传到函数里，再次调用。<br>但要注意和现在的链表不能断开，因此写出head.next = swapPairs(head.next);  </p>
<p>考虑完边界情况之后，写出代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( p != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        pre.next = p.next;</span><br><span class="line">        p.next = pre;</span><br><span class="line">        head.next = swapPairs(head.next);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看题解之后的简化代码如下，哎，路还很长，啥时候能写出这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the list has no node or has only one node left.</span></span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nodes to be swapped</span></span><br><span class="line">        ListNode firstNode = head;</span><br><span class="line">        ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swapping</span></span><br><span class="line">        firstNode.next  = swapPairs(secondNode.next);</span><br><span class="line">        secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now the head is the second node</span></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-26</title>
    <url>/2020/06/21/leetcode-26/</url>
    <content><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组，你需要在原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题想通过其实不难，但是想到一个好的办法挺难的。<br>我的思路是记下重复元素的个数与最后一个重复元素的下标，接着向前覆盖就可以了<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> surplus = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">             &#123;</span><br><span class="line">                 surplus++;</span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (surplus &gt; <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; k; j++)</span><br><span class="line">                 &#123;</span><br><span class="line">                     nums[j - surplus] = nums[j];</span><br><span class="line">                 &#125;</span><br><span class="line">                 k -= surplus;</span><br><span class="line">                 i -= surplus;</span><br><span class="line">                 surplus = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (surplus &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k-=surplus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>方法：双指针法<br>可以看到我们并不需要在数组的下标上下太大的功夫，只需定义两个指针，一快一慢。<br>我们放置两个指针i与j，其中i为慢指针，j为快指针。<br>当nums[i] = nums[j]时，说明此时元素重复，j后移一个元素<br>当nums[i] != nums[j]时，说明已经跳过重复项，此时需要把nums[j]的值给nums[i + 1],接着i后移。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-242</title>
    <url>/2020/06/30/leetcode-242/</url>
    <content><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题拿到我首先想到哈希表，先遍历s把字母和字母对应出现的次数记录在哈希表，再遍历t，如果t中字母有与s相同并且次数大于0，那么就将其次数–，否则返回false，最后再通过s串遍历一遍哈希表查看元素次数有没有大于0。</p>
<p>但是我忽略了一个重要的前提，那就是如果两个串是字母异位词，那么它们的长度肯定相等！</p>
<p>因此，最后的遍历就不需要了。</p>
<p>一开始写下的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(t.charAt(i)) &amp;&amp; map.get(t.charAt(i)) &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(t.charAt(i), map.get(t.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(t.charAt(i)) &amp;&amp; map.get(t.charAt(i)) &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(t.charAt(i), map.get(t.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-278</title>
    <url>/2020/06/27/leetcode-278/</url>
    <content><![CDATA[<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:</p>
<p>给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。 </p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个题目比较简单，但是还是体现出我编程功底的薄弱。。。</p>
<p>这道题所用的算法很显然，为二分法。</p>
<p>但是有几个细节值得注意，一个是二分时若采用 (left + right) / 2 的方法计算，当int 很大时很容易溢出，我们用 left+(right−left) / 2 来代替前者。</p>
<p>第二个细节是，假如isBadVersion(mid)为真，也就是 mid 为假版本，那么就是说 mid 之后都为假版本，并且 mid + 1 到 n 不可能是第一个错误的版本，但是mid是可能的，所以说此时应该搜索 left 到 mid ，也就是将 mid 的值给 right。</p>
<p>写下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-283</title>
    <url>/2020/06/27/leetcode-283/</url>
    <content><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>1，必须在原数组上操作，不能拷贝额外的数组。<br>2，尽量减少操作次数。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>哈哈哈，这题上来大概想了一想就会了，一会儿就ac了。</p>
<p>我的思路是这样的，采用双指针(我本来不知道这就是双指针的，看了题解才知道)，遍历一遍数组将不是零的元素覆盖到数组前部，前部指针++，那么到最后非零元素全部覆盖到前面，最后只要把从慢指针到数组末尾的元素全部置零即可。</p>
<p>贴上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>看了题解之后发现有更好的解法的，其实能想到赋值，应该也能想到交换，也是双指针的思路，只不过换成了交换。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[k++],nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-28</title>
    <url>/2020/07/01/leetcode-28/</url>
    <content><![CDATA[<h1 id="实现strStr函数"><a href="#实现strStr函数" class="headerlink" title="实现strStr函数"></a>实现strStr函数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>示例 2:</p>
<p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>匹配字符串问题，想起来数据结构课上学过kmp算法，但是学的糊里糊涂，和没学一样，于是乎就用暴力法解题吧。但是又因为不熟练，暴力法写的都零零碎碎的，哎，最终参考了别人的代码才写出来，真的太菜了。</p>
<h3 id="法一：暴力法"><a href="#法一：暴力法" class="headerlink" title="法一：暴力法"></a>法一：暴力法</h3><p>暴力法其实就是双指针法，一快一慢，慢指针记录快指针需要回溯的位置。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,k = i;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j))</span><br><span class="line">           &#123;</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               i = ++k;</span><br><span class="line">               j = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：Rabin-Karp算法"><a href="#法二：Rabin-Karp算法" class="headerlink" title="法二：Rabin Karp算法"></a>法二：Rabin Karp算法</h3><p>这里就贴个图，等到时候再开一个帖细讲。</p>


<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// function to convert character to integer</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">charToInt</span><span class="params">(<span class="keyword">int</span> idx, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)s.charAt(idx) - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line">    <span class="keyword">if</span> (L &gt; n) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base value for the rolling hash function</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">26</span>;</span><br><span class="line">    <span class="comment">// modulus value for the rolling hash function to avoid overflow</span></span><br><span class="line">    <span class="keyword">long</span> modulus = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the hash of strings haystack[:L], needle[:L]</span></span><br><span class="line">    <span class="keyword">long</span> h = <span class="number">0</span>, ref_h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) &#123;</span><br><span class="line">      h = (h * a + charToInt(i, haystack)) % modulus;</span><br><span class="line">      ref_h = (ref_h * a + charToInt(i, needle)) % modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == ref_h) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说实话这里没搞明白为什么要这么做</span></span><br><span class="line">    <span class="comment">// const value to be used often : a**L % modulus</span></span><br><span class="line">    <span class="keyword">long</span> aL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) aL = (aL * a) % modulus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="comment">// compute rolling hash in O(1) time</span></span><br><span class="line">      h = (h * a - charToInt(start - <span class="number">1</span>, haystack) * aL</span><br><span class="line">              + charToInt(start + L - <span class="number">1</span>, haystack)) % modulus;</span><br><span class="line">      <span class="keyword">if</span> (h == ref_h &amp;&amp; haystack.substring(start,start + L).equals(needle)) <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-310</title>
    <url>/2020/06/06/leetcode-310/</url>
    <content><![CDATA[<h1 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>
<p>格式</p>
<p>该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。</p>
<p>你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。</p>
<p>示例 1:</p>
<p>输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</p>
<pre><code>  0
  |
  1
 / \
2   3 </code></pre><p>输出: [1]<br>示例 2:</p>
<p>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</p>
<pre><code>0  1  2
 \ | /
   3
   |
   4
   |
   5 </code></pre><p>输出: [3, 4]</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题我暂时想不到什么好的办法，只能用暴力法了，也就是对每一个节点进行遍历，这里采用深度优先遍历，然后记下每次遍历的最大深度值，在其中选一个最小的然后返回其下标就可以了。</p>
<p>果不其然，超时了。。。。。</p>
<p>我还沾沾自喜能写出来这道题，唉，好烦，先把自己的代码贴了吧，办法明天再想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0代表未访问， 1代表已访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mdepth;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; depths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cp[]: edges)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.get(cp[<span class="number">0</span>]).add(cp[<span class="number">1</span>]);</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mdepth = <span class="number">0</span>;</span><br><span class="line">            dfs(adj, visited, i, <span class="number">0</span>);</span><br><span class="line">            depths.add(mdepth);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                visited[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = depths.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depths.get(i) &lt;= min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = depths.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depths.get(i) == min)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adj, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> v0, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visited[v0] = <span class="number">1</span>;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; mdepth)</span><br><span class="line">        &#123;</span><br><span class="line">            mdepth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: adj.get(v0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               dfs(adj, visited, i, depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>建立好邻接表与度表</p>
<p>从边缘开始，先找到所有度为1的节点，进队列，接着用队列处理这些节点，即在队列中将这些节点删除，并修改对应的度表，在队列为空后，再将度为1的节点进队处理。</p>
<p>注意一次缩图要将所有度为1的节点均删除，删到最后1-2个节点时停止。</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//m用于保存n的值，便于degrees数组的遍历</span></span><br><span class="line">        <span class="keyword">int</span> m = n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立队列以便对图的节点进行处理</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立度表</span></span><br><span class="line">        <span class="keyword">int</span>[] degrees = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解数组</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//邻接表的建立</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cp[]: edges)</span><br><span class="line">        &#123;</span><br><span class="line">            adj.get(cp[<span class="number">0</span>]).add(cp[<span class="number">1</span>]);</span><br><span class="line">            adj.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">            degrees[cp[<span class="number">0</span>]]++;</span><br><span class="line">            degrees[cp[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//度为1的节点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (degrees[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历删除最外圈度为1的节点</span></span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = q.poll();</span><br><span class="line">                degrees[temp] = -<span class="number">1</span>;   <span class="comment">//出队节点度置-1便于最后判断剩余节点</span></span><br><span class="line">                m--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i: adj.get(temp))</span><br><span class="line">                &#123;</span><br><span class="line">                    degrees[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (degrees[i] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断剩余节点并输出根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (degrees[i] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-350</title>
    <url>/2020/06/26/leetcode-350/</url>
    <content><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1:</p>
<p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]<br>示例 2:</p>
<p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]<br>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>我们可以不考虑输出结果的顺序。<br>进阶:</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>多亏了之前做过的题目，这道题拿到手两种方法都想到了。</p>
<h3 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h3><p>采用哈希表记录下数组每个元素出现的次数，由于需要节省空间，我们将长度小的那个数组添加进哈希表。</p>
<p>首先将这个数组添加进hashmap中，value的值即为每个元素出现的次数。接着我们遍历第二个数组，检查数字在hashmap中是否存在，若存在并且计数为正，那么将该数字添加到答案并且减少hashmap中的计数。</p>
<p>举例如图所示：</p>
<img src="/2020/06/26/leetcode-350/350_1.jpg" class title="哈希表举例">

<p>代码如下：<br>注：map的getOrDefault(key,defaultvalue)方法意为当Map集合中有这个key元素时，就使用这个元素对应的value值，否则使用定义的defaultvalue值。<br>例如：map.getOrDefault(“Algorithms”,”yes”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">        m.put(n, m.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = m.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k++] = n;</span><br><span class="line">            m.put(n, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：排序法"><a href="#法二：排序法" class="headerlink" title="法二：排序法"></a>法二：排序法</h3><p>有序数组什么都好说！</p>
<p>具体方法为用两个指针分别指向nums1与nums2数组，接着：</p>
<img src="/2020/06/26/leetcode-350/350_2.jpg" class title="排序法">
<p>最后返回nums1数组的前 k 个元素即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后贴上自己写的代码："><a href="#最后贴上自己写的代码：" class="headerlink" title="最后贴上自己写的代码："></a>最后贴上自己写的代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Integer i : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(i))</span><br><span class="line">            &#123;</span><br><span class="line">                hashmap.put(i, hashmap.get(i) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> hashmap.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Integer j : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(j) &amp;&amp; hashmap.get(j) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(j);</span><br><span class="line">                hashmap.put(j, hashmap.get(j) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-36</title>
    <url>/2020/06/28/leetcode-36/</url>
    <content><![CDATA[<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<img src="/2020/06/28/leetcode-36/36_1.jpg" class title="数独">

<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题拿到手之后，大概想了一想肯定是用哈希表来保存数独中的元素，行，列，和九宫格内都不能出现重复的数字，我一开始想的是遍历数组三次，然后每次将行和列还有九宫格内的元素分别添加进哈希表中，接着判重，但是在将九宫格内的元素添加进哈希表时出现了问题，有很多数字需要去凑，导致很麻烦。</p>
<p>先贴一下自己的代码吧，太菜了qaq。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,m = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>)  &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(board[i][j])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> map.put(board[i][j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (board[j][i] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(board[j][i])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> map.put(board[j][i], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &lt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; (m - m % <span class="number">3</span>) + <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; (<span class="number">3</span> * (m % <span class="number">3</span>)) + <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>)  &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.containsKey(board[i][j])) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> map.put(board[i][j], <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j = <span class="number">3</span> * (m % <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            m++;</span><br><span class="line">            j = (m % <span class="number">3</span> == <span class="number">0</span>)? <span class="number">0</span> : <span class="number">3</span> * (m % <span class="number">3</span>);</span><br><span class="line">            i = m - m % <span class="number">3</span>;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一部分九宫格凑数属实感觉自己像个智障。</p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>其实我们可以换一个思路，多牺牲一点空间，只遍历一次数组。</p>
<p>那么如何做到只遍历一次数组呢？</p>
<p>我们需要考虑数组的每一个元素应该放到哈希表的哪里，而不是去考虑哈希表接下来应该放数组的哪个元素。</p>
<p>在遍历到每一个元素时，去判断该元素应该添加进哪一个哈希表中，或是哪一个九宫格中。</p>
<p>这里我们用到了哈希表数组，这是我没有想到过的，其实遍历一次肯定要多牺牲一点空间的,这里对空间的利用很巧妙，我觉得可以学到挺多的。</p>
<p>我们给出算法的思路：</p>
<p>·遍历数独<br>·计算每一个数组的元素应该放置到哈希表的位置，放置时判断哈希表中是否含有改元素，若没有，将其次数计为1，若有则return false</p>
<p>给出官方代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了三个哈希数组来分别保存行列以及九宫格中的元素。</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] rows = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] columns = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] boxes = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            columns[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">            boxes[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (<span class="keyword">int</span>)num;</span><br><span class="line">                    <span class="keyword">int</span> box_index = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    </span><br><span class="line">                    rows[i].put(n, rows[i].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    columns[j].put(n, columns[j].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (rows[i].get(n) &gt; <span class="number">1</span> || columns[j].get(n) &gt; <span class="number">1</span> || boxes[box_index].get(n) &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-387</title>
    <url>/2020/06/29/leetcode-387/</url>
    <content><![CDATA[<h1 id="字符串中第一个唯一字符"><a href="#字符串中第一个唯一字符" class="headerlink" title="字符串中第一个唯一字符"></a>字符串中第一个唯一字符</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>示例：</p>
<p>s = “leetcode”<br>返回 0</p>
<p>s = “loveleetcode”<br>返回 2</p>
<p>提示：你可以假定该字符串只包含小写字母。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题首先遍历一遍字符串是必须的，因为不知道字符会出现在哪个位置。</p>
<p>其次，我是想到用哈希表的，我想的是将元素添加到哈希表中之前，先判断它是否在哈希表中，如果在，那么在哈希表中删除该元素，如果不在那么就添加进哈希表。</p>
<p>到这里为止我的思路都没有出现偏差，但是接下来我转而去想哈希表会不会保留元素插入的顺序，因为如果保留的话，那哈希表中的第一个元素就是我们想要的那个字符，但答案肯定是不会的，因为哈希表是无序的，然后到这个时候我就想放弃用哈希表了，但是如果转而考虑字符串，其实能解决，很简单。。我就是没想到————字符串本身是具有顺序的！</p>
<p>那么一切都解决了，我们在最后遍历哈希表的时候只要对着字符串原本的顺序进行遍历，看哪个字符先在哈希表中出现，就是我们需要的答案。</p>
<p>后来一看题解，其实没有必要去看重复元素，直接记下元素出现的次数，接着按字符串顺序遍历哈希表找出第一个出现次数为一的元素就可以了。</p>
<p>我觉得我漏掉这个思路的原因肯定是我没有好好地去想，或者是思维有定式。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:在找不到下标时一般都是返回-1的。 </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-38</title>
    <url>/2020/07/03/leetcode-38/</url>
    <content><![CDATA[<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>第一项是数字 1</li>
</ol>
<p>描述前一项，这个数是 1 即 “一个 1 ”，记作 11</p>
<p>描述前一项，这个数是 11 即 “两个 1 ” ，记作 21</p>
<p>描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211</p>
<p>描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221</p>
<p>示例 1:</p>
<p>输入: 1<br>输出: “1”<br>解释：这是一个基本样例。<br>示例 2:</p>
<p>输入: 4<br>输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我自己是用迭代写的，思路大概就是遍历str，如果前后两个元素相等那么count++，不相等就将count和该元素append到stringbuffer中，并置count为1。</p>
<p>注意每次循环后都要更新str，并将ans置零。</p>
<p>贴上使用循环的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1"</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span> count = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; str.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == str.length() - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.append(count);</span><br><span class="line">                    ans.append(str.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) != str.charAt(i + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.append(count);</span><br><span class="line">                    ans.append(str.charAt(i));</span><br><span class="line">                    count = <span class="string">'1'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = <span class="keyword">new</span> String(ans);</span><br><span class="line">            ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            count = <span class="string">'1'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了题解之后发现能用递归，我总是想不到去用递归，哎。</p>
<p>将自己的代码修改成使用递归处理后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = countAndSay(n - <span class="number">1</span>);</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span> count = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == str.length() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.append(count);</span><br><span class="line">                ans.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) != str.charAt(i + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.append(count);</span><br><span class="line">                ans.append(str.charAt(i));</span><br><span class="line">                count = <span class="string">'1'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = <span class="keyword">new</span> String(ans);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-7</title>
    <url>/2020/06/29/leetcode-7/</url>
    <content><![CDATA[<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<p>输入: 123<br>输出: 321<br> 示例 2:</p>
<p>输入: -123<br>输出: -321<br>示例 3:</p>
<p>输入: 120<br>输出: 21<br>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目很简单，大致思路就是求出每一位的数字，然后加权和。</p>
<p>但是还能优化，比如可以在求出某位数字的同时进行求和。</p>
<p>还有一个问题就是超过int范围，我测试了java超过有符号数int范围[-2^31 - 2^31-1]后好像会保留两端的数。</p>
<p>先把自己的代码贴了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Math.abs(x);</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n % <span class="number">10</span>;</span><br><span class="line">            list.add(m);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ans += list.get(i) * Math.pow(<span class="number">10</span>, list.size() - <span class="number">1</span> - i);</span><br><span class="line">            <span class="keyword">if</span> (ans == Math.pow(<span class="number">2</span>,<span class="number">31</span>) - <span class="number">1</span> &amp;&amp; i &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> - ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>然后看题解发现代码可以优化，也就是将两个操作放到一个循环里面,注意别忘了对溢出进行提前的判断。</p>
<img src="/2020/06/29/leetcode-7/7_1.jpg" class title="整数反转">

<p>事实上，一开始给出的x的开头两位分别不会超过2和1，所以说反转之后的末尾一位最多为2，肯定不会超过7和小于-8，因此第三点判断其实是多余的。</p>
<p>修改后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-48</title>
    <url>/2020/06/28/leetcode-48/</url>
    <content><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>示例 2:</p>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="方法一：转置加翻转"><a href="#方法一：转置加翻转" class="headerlink" title="方法一：转置加翻转"></a>方法一：转置加翻转</h3><p>这个方法有一说一完全想不到啊，好烦啊，感觉自己的智商完全不够用。</p>
<p>这个方法是先转置矩阵，接着翻转每一行。时间复杂度为O(n)。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[i][j];</span><br><span class="line">                matrix[i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：旋转四个元素的矩形"><a href="#方法二：旋转四个元素的矩形" class="headerlink" title="方法二：旋转四个元素的矩形"></a>方法二：旋转四个元素的矩形</h3><p>做法如图所示：</p>
<img src="/2020/06/28/leetcode-48/48_1.jpg" class title="旋转矩形">

<p>这个方法不难想到，但是细节很多，特别是每一个元素转移前与转移后的坐标需要搞清楚。<br>我觉得自己还缺乏一定的耐心，要灵活变通一点。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">                matrix[i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-66</title>
    <url>/2020/06/26/leetcode-66/</url>
    <content><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题没啥多说的，一个是注意不能忽略了进位的情况，既然能想到进位，那肯定不能忽视了全是9的情况，那需要重新建立一个数组并将第一个元素置一。</p>
<p>另外一个就是代码的简练度问题，个人觉得想得多那肯定写的少，逻辑要清晰，想明白了再写。</p>
<p>先贴上自己写的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= digits.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[digits.length - <span class="number">1</span> - i] == <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[digits.length - <span class="number">1</span> - i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; </span><br><span class="line">                digits[digits.length - <span class="number">1</span> - i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>其实仔细想一下，不管最后一位是9还是不是9，都需要++，那么先++，将这一位除以10的余数给原来这位数，再去判0，如果不为0，那么直接返回这个数组，为零继续这个循环，如果循环到最后一次还未结束，那么说明全为9，需要建立新数组。</p>
<p>说白了就是找到为9和不为9时的共同点，就不用分if else了，节省了代码。</p>
<p>优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-94</title>
    <url>/2020/06/01/leetcode-94/</url>
    <content><![CDATA[<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3</p>
<p>输出: [1,3,2]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归法应该很容易，这里直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">       inorderTraversal(root.left);</span><br><span class="line">       list.add(root.val);</span><br><span class="line">       inorderTraversal(root.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法以我目前的水平，只能写出循环里面的东西，在外面再加一层循环我没有想到，循环条件，一个字，难！</p>
<p>上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();s</span><br><span class="line">        TreeNode top = root;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            stack.push(top);</span><br><span class="line">            top = top.left;</span><br><span class="line">            &#125;</span><br><span class="line">            top = stack.pop();</span><br><span class="line">            list.add(top.val);</span><br><span class="line">            top = top.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-8</title>
    <url>/2020/06/30/leetcode-8/</url>
    <content><![CDATA[<h1 id="字符串转换整数"><a href="#字符串转换整数" class="headerlink" title="字符串转换整数"></a>字符串转换整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题非常重要！！！！！可以说是刷到现在收获最大的题之一。</p>
<p>我们先介绍一般的想法，按题目的意思，我们肯定先将字符串前面的空格去掉，接着判断字符串的符号，无符号则默认为正，在这些都结束之后，我们需要找之后的数字，到第一个不是数字的字符为止，接着将这些数字转换成对应的整数，还要进行溢出处理。在前天刚做完一道溢出处理的题目后，遇到这个题我还挺兴奋的。</p>
<p>接下来先把自己写的代码贴了，前有flag判断数字中的字符，后有flag判断整数的正负，这着实使我们的代码变得十分的臃肿，那么为什么会出现这种情况，以及为什么我们要定义flag呢，具体的问题我们慢慢分析。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.length() &amp;&amp; str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(str.charAt(i)))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.append(str.charAt(i));</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag &amp;&amp; (str.charAt(i) == <span class="string">'-'</span> || str.charAt(i) == <span class="string">'+'</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.append(str.charAt(i));</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ans.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (ans.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (ans.charAt(i) == <span class="string">'+'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (answer &gt; Integer.MAX_VALUE / <span class="number">10</span> || (answer == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (ans.charAt(i) - <span class="string">'0'</span>) &gt; <span class="number">7</span>)) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">if</span> (answer &lt; Integer.MIN_VALUE / <span class="number">10</span> || (answer == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (ans.charAt(i) - <span class="string">'0'</span>) &gt; <span class="number">8</span>)) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">               <span class="keyword">if</span> (flag)</span><br><span class="line">               &#123;</span><br><span class="line">                   answer = answer * <span class="number">10</span> - (ans.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   answer = answer * <span class="number">10</span> + (ans.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么我们可以明显地看到，标志位的设置会使代码变得十分繁杂，但是采用这种思路又不可避免地要用到flag。在我们从字符串中取出每一位字符时，我们自然而然地会去想，如果取出的是什么什么字符，那么应该怎么去处理。举个例子，在取出加减号时，有可能是空格后的加减号，也有可能是数字中夹杂着的加减号，假如我们放在一起判断的话，就应该要加一个标志位，在第一次遇到加减号后，flag就设置为true，之后就忽略后面的加减号。当然这只是一种简单的情况，实际情况比这个更加复杂，那么代码会更加的繁杂。<br>这里我认为我写的代码用的flag不够多是因为这个事情是有一定的顺序的，或者说是有规律的，也就是一开始是空格，接着是正负号或数字，最后是乱七八槽的字母，其实这道题还是比较清晰的。</strong></p>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>那么接下来就要引入这道题一个另类的解法，采用<strong>有限状态机</strong>。</p>
<p>什么是有限状态机呢？这里我准备再写一个博客来介绍它。</p>
<p>这里直接简单的说一下：<br>字符串处理的题目往往会涉及到复杂的流程以及条件情况。</p>
<p>按通常的思路，我们会去判断现在的字符是什么类型的，这在状态机中被称为条件，也就是由一个状态过渡到另一个状态所需要满足的条件，那么条件有很多，不同状态之间的条件可能是相同的，那么这样一来就不用去定义标志位了，因为本身的状态已经确定了。</p>
<p>对于这道题而言我们定义四个状态，一个是start开始状态，第二个是遇到符号后的signed状态，第三个是进入数字后的in_number状态，最后是出数字后的end状态。<br>那么这几个有限的状态有着如图这样的关系，箭头上即写着状态转移需要的条件：</p>
<img src="/2020/06/30/leetcode-8/8_1.jpg" class title="有限状态机图">
<p>也可以用下面的表来进行描述：</p>
<img src="/2020/06/30/leetcode-8/8_2.jpg" class title="有限状态机表">

<p>接下来就是写代码了,照着官方java解敲的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义四个状态</span></span><br><span class="line">    <span class="keyword">final</span> String START = <span class="string">"start"</span>;</span><br><span class="line">    <span class="keyword">final</span> String SIGNED = <span class="string">"signed"</span>;</span><br><span class="line">    <span class="keyword">final</span> String IN_NUM = <span class="string">"in_number"</span>;</span><br><span class="line">    <span class="keyword">final</span> String END = <span class="string">"end"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    String state = START;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义状态表</span></span><br><span class="line">    Map&lt;String, String[]&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sign 用于记录整数的符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录转换成的整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Automaton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//记录下每个状态能到达的状态</span></span><br><span class="line">      map.put(START,<span class="keyword">new</span> String[] &#123;START,SIGNED,IN_NUM,END&#125;);</span><br><span class="line">      map.put(SIGNED,<span class="keyword">new</span> String[] &#123;END,END,IN_NUM,END&#125;);</span><br><span class="line">      map.put(IN_NUM,<span class="keyword">new</span> String[] &#123;END,END,IN_NUM,END&#125;);</span><br><span class="line">      map.put(END,<span class="keyword">new</span> String[] &#123;END,END,END,END&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件判断函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//状态转移函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//通过原有的状态及条件获取新的状态</span></span><br><span class="line">      state = map.get(state)[get_col(c)];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断新的状态采取什么操作</span></span><br><span class="line">      <span class="keyword">if</span> (state.equals(IN_NUM)) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span>) &#123;</span><br><span class="line">          ans = Math.min(ans, Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ans = Math.min(ans, -(<span class="keyword">long</span>)Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(SIGNED))  &#123;</span><br><span class="line">        sign = c == <span class="string">'+'</span>? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Automaton automaton = <span class="keyword">new</span> Automaton();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++ ) &#123;</span><br><span class="line">      automaton.get(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> automaton.sign * ((<span class="keyword">int</span>)automaton.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望自己能慢慢学会这个解法。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-71</title>
    <url>/2020/06/17/leetcode-71/</url>
    <content><![CDATA[<h1 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p>示例 1：</p>
<p>输入：”/home/“<br>输出：”/home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p>
<p>输入：”/../“<br>输出：”/“<br>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>示例 3：</p>
<p>输入：”/home//foo/“<br>输出：”/home/foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p>
<p>输入：”/a/./b/../../c/“<br>输出：”/c”<br>示例 5：</p>
<p>输入：”/a/../../b/../c//.//“<br>输出：”/c”<br>示例 6：</p>
<p>输入：”/a//b////c/d//././/..”<br>输出：”/a/b/c”</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题思路不难，但题目有点坑，像/…这种测试案例很无语。。</p>
<p>像这种题我觉得自己对于许多java中的容器方法都不是很了解，慢慢来吧。</p>
<p>自己写的代码(不适用于/…这种情形)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(path.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; path.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (path.charAt(i) == <span class="string">'/'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'.'</span>) </span><br><span class="line">                     &#123;</span><br><span class="line">                         stack.pop();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'/'</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> stack.push(path.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (path.charAt(i) == <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'.'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (stack.peek() == <span class="string">'/'</span> || stack.peek() == <span class="string">'.'</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> stack.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        stack.push(path.charAt(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> stack.push(path.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'/'</span> || stack.peek() == <span class="string">'.'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">            <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[list.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h2><p>看了大佬的题解之后，学到了挺多的。</p>
<p>路径的简化本质上是获得每一层路径的名称</p>
<p>字符串中的/不入栈，靠它来分割路径名称</p>
<p>如果是 “..” 还要再判断是否为空才能弹出栈</p>
<p>如果是 “.” 则什么也不要做</p>
<p>如果不为空也不为 “.” 这说明当前元素是路径信息，入栈即可</p>
<p>最后遍历完之后，先判断栈中是否有元素，没有则返回 “/”</p>
<p>如果有元素，则使用 StringBuilder 来存放可变字符串，最后返回 ans 即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 首先将字符串以 “/” 分隔存储到新的字符数组 str 中</span></span><br><span class="line">        String[] str = path.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : str) &#123;</span><br><span class="line">            <span class="comment">// 如果数组非空,且访问到的是 “..” 则说明要返回上一级,要将当前元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> ( s.equals(<span class="string">".."</span>) ) &#123;</span><br><span class="line">                <span class="comment">// 这里用到增强型 for 循环不能同时判断，需要再次判空</span></span><br><span class="line">                <span class="comment">// 而普通 for 循环则可写成( !stack.isEmpty() &amp;&amp; s.equals("..") )</span></span><br><span class="line">                <span class="keyword">if</span> ( !stack.isEmpty() ) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;                </span><br><span class="line">            <span class="comment">// 如果数组非空并且当前元素不是 “.” 说明当前元素是路径信息，要入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !s.equals(<span class="string">""</span>) &amp;&amp; !s.equals(<span class="string">"."</span>) ) &#123;</span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈内没有元素说明没有路径信息，返回 “/” 即可</span></span><br><span class="line">        <span class="keyword">if</span> ( stack.isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里用到 StringBuilder 操作字符串，效率高</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.size(); i++) &#123;</span><br><span class="line">            ans.append( <span class="string">"/"</span> + stack.get(i) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/06/17/linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="命令格式与目录处理命令ls"><a href="#命令格式与目录处理命令ls" class="headerlink" title="命令格式与目录处理命令ls"></a>命令格式与目录处理命令ls</h3><p>ls -a 列出目录所有文件，包含以.开始的隐藏文件<br>ls -A 列出除.及..的其它文件<br>ls -r 反序排列<br>ls -t 以文件修改时间排序<br>ls -S 以文件大小排序<br>ls -h 以易读大小显示<br>ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来<br>ls -i iNode  </p>
<h3 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h3><h3 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>命令所在路径：/bin/touch<br>执行权限：所有用户<br>语法:touch [文件名]<br>功能描述：创建空文件<br>范例：touch haha.list  touch “program files”  </p>
<h4 id="cat-tac"><a href="#cat-tac" class="headerlink" title="cat tac"></a>cat tac</h4><p>命令所在路径：/bin/cat<br>语法：cat [文件名]<br>功能描述：显示文件内容<br>         -n 显示行号<br>范例: cat /etc/issue<br>      cat -n /etc/services<br>tac 为反向显示  </p>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>语法: more [文件名]<br>功能描述：分页显示文件内容<br>实例： more /etc/services<br>使用 space或f 翻页<br>     enter  换行<br>     q或Q 退出  </p>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>功能描述：向上翻页或查找</p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>功能描述：查看文件的前几行<br>语法：head -n 行数 文件路径<br>默认为10行</p>
<h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>功能描述：查看文件的前几行<br>语法：tail -n 行数 文件路径<br>      tail -f 动态显示文件内容</p>
<h3 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h3><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>命令英文原意：link<br>命令所在路径：/bin/ln<br>语法：ln -s [原文件] [目标文件]<br>       -s 创建软链接（类似于windows快捷方式）<br>功能描述：生成链接文件<br>硬链接与cp -p区别：<br>1、硬链接文件与原文件同步更新<br>2、硬链接文件与原文件iNode值相同<br>3、硬链接不能跨分区<br>4、不能针对目录使用</p>
<h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><h3 id="权限管理命令chmod"><a href="#权限管理命令chmod" class="headerlink" title="权限管理命令chmod"></a>权限管理命令chmod</h3><p>命令英文原意：change the permissions mode of a file<br>语法：chmod [{ugoa} {+-=} {rwx}] [文件或目录]<br>            [mode=421] [文件或目录]（r = 4，w = 2，x = 1）<br>            -R 递归修改<br>            将目录与其下文件权限均修改<br>功能描述：改变文件或目录权限<br>注意：<strong>对文件来说 r权限说明我们可以查看文件内容 对目录来说 可以列出目录中的内容<br>                w权限可以修改文件内容                  可以在目录中创建、删除文件<br>                x权限可以执行文件                      可以进入目录</strong></p>
<h3 id="其他权限管理命令"><a href="#其他权限管理命令" class="headerlink" title="其他权限管理命令"></a>其他权限管理命令</h3><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>命令英文原意：change owner<br>语法：chown [用户][文件或目录]<br>功能描述：改变文件或目录的所有者（只允许root用户改变）<br>范例 chown cmq /root/tmp/haha</p>
<h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>命令功能：改变文件或目录的所属组</p>
<h4 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h4><p>命令英文原意：the user file-creation mask<br>命令所在路径：Shell内置命令<br>执行权限：所有用户<br>语法 umask [-S]<br>     -S表示以rwx形式显示新建文件缺省权限<br>注意： <strong>touch的文件不具备可执行权限但mkdir的目录具有</strong></p>
<h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>命令名称：find<br>命令所在路径：/bin/find<br>执行权限：所有用户<br>语法：find [搜索范围][匹配条件]<br>功能描述：文件搜索<br>示例：find / -name - iname（不区分大小写） -size(参数为+多少则为大于，-多少则为小于)  -user [..]<br>      find /etc -cmin -amin -mmin(change文件属性, access访问时间, modify文件内容) -5(5分钟)<br>      -a -o 分别为连接符表示与和或<br>      -inum 文件的i结点<br>find /etc -name inittab -exec ls -l {} ;</p>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>命令所在路径：/usr/bin/locate<br>语法：locate 文件名<br>功能描述：在文件资料库中查找文件<br>示例：locate inittab<br>拓展： updatedb命令用来更新文件资料库<br>       locate -i 命令可以不区分大小写搜索文件<br>注：<strong>文件资料库不收录tmp文件夹下的文件</strong></p>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>命令路径：/usr/bin/which<br>语法：which 命令<br>功能描述：搜索命令所在目录及别名信息<br>范例：which ls</p>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>功能描述：搜索命令所在目录及帮助文档路径</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>命令所在路径：/bin/grep<br>执行权限:所有用户<br>语法：grep -iv [指定子串][文件]<br>功能描述：在文件中搜寻字串匹配的行并输出<br>         -i 不区分大小写<br>         -v 排除指定子串<br>范例：grep mysql /root/install.log<br>      grep -v ^# /etc/inittab</p>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>命令原意：manual<br>命令所在路径：/usr/bin/man<br>语法：man [命令或配置文件]<br>功能描述：获得帮助信息<br>范例：man ls<br>     查看ls命令的帮助信息<br>     man services<br>     查看配置文件services的帮助信息</p>
<h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3><p>功能：查看命令功能</p>
<h3 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h3><p>功能：查看配置文件帮助</p>
<h3 id="命令-–help-也可以获得帮助"><a href="#命令-–help-也可以获得帮助" class="headerlink" title="命令+ –help 也可以获得帮助"></a>命令+ –help 也可以获得帮助</h3><h3 id="info命令与man命令大同小异"><a href="#info命令与man命令大同小异" class="headerlink" title="info命令与man命令大同小异"></a>info命令与man命令大同小异</h3><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p>命令所在路径:shell内置命令<br>语法：help 命令<br>功能：获得Shell内置命令的帮助信息<br>范例 ：help umask<br>拓展：我们使用的shell为bash，shell为指令解释器</p>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>命令所在路径：/usr/sbin/useradd<br>执行权限：root<br>语法：useradd 用户名<br>功能描述：添加新用户</p>
<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>命令所在路径：/usr/bin/passwd<br>执行权限：所有用户<br>语法：passwd 用户名<br>功能：设置用户密码</p>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>命令所在路径:/usr/bin/who<br>执行权限：所有用户<br>语法：who<br>功能：查看登录用户信息</p>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>命令所在路径：/usr/bin/w<br>执行权限：所有用户<br>语法：w<br>功能：查看登录用户详细信息</p>
<h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>命令英文原意：GNU zip<br>命令所在路径：/bin/gzip<br>执行权限：所有用户<br>语法：gzip [文件]<br>功能描述：压缩文件(不能压缩目录)<br>压缩后文件格式：.gz</p>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p>命令英文原意：GNU unzip<br>命令所在路径：/bin/gunzip<br>执行权限:所有用户<br>语法：gunzip [压缩文件]<br>功能描述：解压缩.gz的压缩文件<br>拓展：使用 gzip -d同理 </p>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>命令所在路径：/bin/tar<br>执行权限：所有用户<br>语法：tar 选项[-z -c -f -v] [压缩后文件名] [目录]<br>     -c 打包<br>     -v 显示详细信息<br>     -f 指定文件名<br>     -z 打包同时压缩<br>     -j 打包同时压缩bzip2<br>功能描述：打包目录<br>压缩后文件格式：.tar.gz<br>拓展：打包和压缩的区别<br>      相同点：打包和压缩都可以将多个文件生成一个文件存储<br>      不同点：压缩操作不但要生成一个文件，还要通过压缩工具对文件进行压缩，来减少文件占用的存储空间大小。</p>
<h3 id="tar命令解压缩"><a href="#tar命令解压缩" class="headerlink" title="tar命令解压缩"></a>tar命令解压缩</h3><p>-x 解包<br>-v 显示详细信息<br>-f 指定压缩文件<br>-z 解压缩<br>-j 解压缩bzip2<br>例：tar -zxvf Japan.tar.gz</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>命令所在路径：/usr/bin/zip<br>执行权限：所有用户<br>语法：zip [-r] [压缩后的文件名] [需要压缩的文件或目录]<br>      -r 压缩目录<br>功能描述： 压缩文件或目录<br>压缩后文件格式：.zip<br>解压缩：unzip</p>
<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>命令所在路径：/usr/bin/bzip2<br>执行权限：所有用户<br>语法：bzip [-k] [文件]<br>      -k 产生压缩文件后保留原文件<br>功能：压缩文件(推荐压缩较大文件)<br>压缩后文件格式：.bz2<br>范例：tar -cjf ***.tar.bz2 ***<br>解压缩： bunzip2 -k [文件名.bz2]<br>        tar -xjf [文件名.tar.bz2]</p>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>命令所在路径：/usr/bin/write<br>执行权限：所有用户<br>语法：write &lt;用户名&gt;<br>功能描述：给用户发信息，以Ctrl + D保存结束<br>前提条件所有用户都得登录在服务器上</p>
<h3 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h3><p>命令所在路径：/usr/bin/wall<br>命令英文原意：write all<br>执行权限：所有用户<br>语法：wall [message]<br>功能描述：发广播信息</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>命令名称：ping<br>命令所在路径：/bin/ping<br>执行权限：所有用户<br>语法：ping 选项 IP地址<br>           -c 指定发送次数<br>功能描述：测试网络连通性</p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>命令名称：ifconfig<br>命令英文原意：interface configure<br>命令所在路径：/sbin/ifconfig<br>执行权限:root<br>语法：ifconfig 网卡名称 IP地址<br>功能描述：查看和设置网卡信息</p>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><p>命令名称：mail<br>命令所在路径：/bin/mail<br>执行权限：所有用户<br>语法：mail [用户名]<br>功能描述：查看和发送电子邮件</p>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>命令所在路径：/usr/bin/last<br>执行权限：所有用户<br>语法：last</p>
<h3 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h3><p>命令所在路径：/usr/bin/lastlog<br>执行权限：所有用户<br>语法：lastlog<br>功能：检查某特定用户上次登录的时间<br>拓展：last -u 512 -u意为uid</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>命令所在路径：/bin/traceroute<br>执行权限：所有用户<br>语法：traceroute<br>功能描述：显示数据包到主机间的路径<br>例：traceroute <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>命令所在路径：/bin/netstat<br>执行权限：所有用户<br>语法：netstat [选项]<br>              -t  tcp协议<br>              -u  UDP协议<br>              -l  监听<br>              -r  路由<br>              -n  显示IP地址和端口号<br>功能描述：显示网络相关信息<br>范例：netstat -tlun 查看本机监听的端口<br>      netstat -an 查看本机所有的网络连接<br>      netstat -rn 查看本机路由表</p>
<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>命令所在路径：/usr/bin/setup<br>执行权限：root<br>语法：setup<br>功能描述：配置网络<br>范例：setup</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>命令位置：/bin/mount<br>执行权限：所有用户<br>命令语法：mount [-t 文件系统] 设备文件名 挂载点<br>命令功能：挂载设备<br>范例： mount -t iso9660 /dev/sr0 /mnt/cdrom<br>设备卸载：umount /dev/sr0</p>
<h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>语法：shutdown [选项] 时间选项<br>      选项：  -c  取消前一个关机命令<br>              -h  关机(halt)<br>              -r  重启(reboot)<br>例：shutdown -h now<br>    shutdown -r now<br>拓展：<br>其他关机命令：halt  poweroff  init 0<br>其他重启命令：reboot  init 6<br>系统运行级别：0  关机<br>             1  单用户<br>             2  不完全多用户，不含NFS服务(网络文件系统，用于两个linux之间的文件共享)<br>             3  完全多用户<br>             4  未分配<br>             5  图形界面<br>             6  重启<br>退出登录命令：logout</p>
<h2 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h2><h3 id="Vim常用操作"><a href="#Vim常用操作" class="headerlink" title="Vim常用操作"></a>Vim常用操作</h3><img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_1.jpg" class title="Vim命令模式命令1">
<p>命令模式输入冒号进入编辑模式，输入iao进入插入模式</p>
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_2.jpg" class title="Vim命令模式命令2">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_3.jpg" class title="Vim命令模式删除命令">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_4.jpg" class title="Vim复制与剪切命令">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_5.jpg" class title="Vim替换或取消命令">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_6.jpg" class title="Vim搜索和替换命令">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_7.jpg" class title="Vim保存修改命令">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_8.jpg" class title="Vim常用操作">

<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="软件包的分类"><a href="#软件包的分类" class="headerlink" title="软件包的分类"></a>软件包的分类</h3><p>1，源码包（未编译，开源，速度相对较慢）<br>   1.1 脚本安装包（写好界面的源码包 install.sh)<br>2，二进制包（已编译，无法看到源码，速度相对较快）</p>
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_9.jpg" class title="源码包优点">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_10.jpg" class title="源码包缺点">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_11.jpg" class title="rpm包优点">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_12.jpg" class title="rpm包缺点">
<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><p>对于yum命令和apt-get命令区别的解释：</p>
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_15.jpg" class title="yum与apt-get的区别">
<h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_13.jpg" class title="rpm包命名规则">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_14.jpg" class title="rpm包依赖性">
<h5 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h5><p>rpm -ivh 包全名<br>选项： -i(install)  安装<br>-v(verbose)  显示详细信息<br>-h(hash)    显示进度<br>–nodeps    不检测依赖性</p>
<h5 id="rpm包升级"><a href="#rpm包升级" class="headerlink" title="rpm包升级"></a>rpm包升级</h5><p>rpm -Uvh 包全名<br>选项： -U(upgrade)   升级</p>
<h5 id="rpm包卸载"><a href="#rpm包卸载" class="headerlink" title="rpm包卸载"></a>rpm包卸载</h5><p>rpm -e 包名<br>选项： -e(erase) 卸载<br>–nodeps 不检查依赖性</p>
<h5 id="查询rpm包是否安装"><a href="#查询rpm包是否安装" class="headerlink" title="查询rpm包是否安装"></a>查询rpm包是否安装</h5><p>rpm -q 包名<br>选项： -q  查询(query)<br>rpm -qa<br>选项： -a  所有(all)</p>
<h5 id="查询软件包详细信息"><a href="#查询软件包详细信息" class="headerlink" title="查询软件包详细信息"></a>查询软件包详细信息</h5><p>rpm -qi 包名<br>选项： -i 查询软件信息(information)<br>       -p 查询未安装包信息(package)</p>
<h5 id="查询软件包中文件安装位置"><a href="#查询软件包中文件安装位置" class="headerlink" title="查询软件包中文件安装位置"></a>查询软件包中文件安装位置</h5><p>rpm -ql 包名<br>选项： -l 列表(list)<br>      -p 查询未安装包信息(package)</p>
<h5 id="查询系统文件属于哪个rpm包"><a href="#查询系统文件属于哪个rpm包" class="headerlink" title="查询系统文件属于哪个rpm包"></a>查询系统文件属于哪个rpm包</h5><p>rpm -qf 系统文件名<br>选项： -f 查询系统文件属于哪个软件包(file)</p>
<h5 id="查询软件包的依赖性"><a href="#查询软件包的依赖性" class="headerlink" title="查询软件包的依赖性"></a>查询软件包的依赖性</h5><p>rpm -qR 包名<br>选项： -R  查询软件包的依赖性(requires)<br>      -p  查询未安装包的信息(package)</p>
<h5 id="rpm包校验"><a href="#rpm包校验" class="headerlink" title="rpm包校验"></a>rpm包校验</h5><p>rpm -V 已安装的包名<br>选项： -V 校验指定RPM包中的文件(verify)<br>校验结果中的8个信息具体内容：</p>

<h5 id="rpm包中文件提取"><a href="#rpm包中文件提取" class="headerlink" title="rpm包中文件提取"></a>rpm包中文件提取</h5><p>rpm2cpio 包全名 | <br>cpio -idv .文件绝对路径</p>
<p>rpm2cpio 为将rpm包转换为cpio格式的命令</p>
<p>cpio为标准工具，它用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio命令：<br>cpio 选项 &lt;[文件|设备]<br>选项： -i copy-in模式，还原<br>       -d 还原时自动新建目录<br>       -v 显示还原过程</p>
<h3 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h3><h4 id="源码包与rpm包区别"><a href="#源码包与rpm包区别" class="headerlink" title="源码包与rpm包区别"></a>源码包与rpm包区别</h4><p>安装前概念不同，安装后安装位置不同</p>
<h4 id="rpm包安装位置"><a href="#rpm包安装位置" class="headerlink" title="rpm包安装位置"></a>rpm包安装位置</h4><img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_17.jpg" class title="rpm包安装默认位置">
<h4 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h4><img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_18.jpg" class title="源码包安装位置">
<h4 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h4><img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_19.jpg" class title="安装位置影响">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_20.jpg" class title="安装位置影响">
<img src="/2020/06/17/linux%E5%AD%A6%E4%B9%A0/Linux_21.jpg" class title="源码包的卸载">]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-88</title>
    <url>/2020/07/05/leetcode-88/</url>
    <content><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>看到这类题目就是用双指针了，不过这里有个小技巧，为了避免增加额外的空间复杂度，我的想法是先将nums1数组中的元素后移nums2.length的长度，接着再从两个数组开头进行双指针。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i + n] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = n;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m + n &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k++] = nums1[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               nums1[k++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m + n)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解优化"><a href="#题解优化" class="headerlink" title="题解优化"></a>题解优化</h2><p>看完官方题解之后，瞬间感觉自己又像个智障了，我为什么就没有多转个弯，直接双指针从数组最后开始比呢，即找更大的数从后面填起。反正两种方法是对称的。</p>
<p>这样一来，就不用移动了，既节省了空间复杂度，又减少了时间复杂度。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">      <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">      <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps：有一说一，题解的代码是真的简洁。。。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>n-皇后问题</title>
    <url>/2020/04/27/n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h1><p>在解决n皇后问题之前，我们先说明一下回溯法</p>
<h2 id="回溯法解决问题的一般步骤及回溯法的特征"><a href="#回溯法解决问题的一般步骤及回溯法的特征" class="headerlink" title="回溯法解决问题的一般步骤及回溯法的特征"></a>回溯法解决问题的一般步骤及回溯法的特征</h2><p>1，针对给出问题，给出解空间；  </p>
<p>2，确定易于搜索的解空间组织结构；  </p>
<p>3，以深度优先的方式搜索解空间，并在搜索中使用剪枝函数避免不必要的搜索。（回溯时可采用递归回溯与迭代回溯）  </p>
<p>用回溯法解题显著特征为在搜索过程中动态产生问题的解空间（分为排列树与子集树），任何时刻，算法只保存从根结点到当前扩展结点的路径。</p>
<h2 id="n-皇后问题的解空间"><a href="#n-皇后问题的解空间" class="headerlink" title="n-皇后问题的解空间"></a>n-皇后问题的解空间</h2><p>数组 x[i] 代表第 i 行的皇后放置在第 x[i] 列上  </p>
<p>若显式约束为 i != j 时，x[i] != x[j]，那么显然皇后问题解空间为n!种排列，因此构造的树为排列树。</p>
<h2 id="n-皇后问题排列树采用剪枝函数压缩结点数"><a href="#n-皇后问题排列树采用剪枝函数压缩结点数" class="headerlink" title="n-皇后问题排列树采用剪枝函数压缩结点数"></a>n-皇后问题排列树采用剪枝函数压缩结点数</h2><p>剪枝函数为：<strong>0 &lt;= i, j &lt;= n, if i != j, then x[i] != x[j] &amp;&amp; |x[i] - x[j]| != |i-j|</strong></p>
<h2 id="采用递归算法实现回溯法解决n-皇后问题"><a href="#采用递归算法实现回溯法解决n-皇后问题" class="headerlink" title="采用递归算法实现回溯法解决n-皇后问题"></a>采用递归算法实现回溯法解决n-皇后问题</h2><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//判断皇后摆放是否冲突，即剪枝函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//从 1 到 t - 1 行分别判断是否冲突</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若满足if判断条件则说明皇后摆放冲突</span></span><br><span class="line">        <span class="keyword">if</span>((x[i] == x[t]) || <span class="built_in">abs</span>(t - i) == <span class="built_in">abs</span>(x[t] - x[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nQueensRec</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> t, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//输出一个可行解</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d, "</span>,x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个一个尝试皇后的摆放</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="comment">//若不冲突，则继续摆放下一行的皇后</span></span><br><span class="line">            <span class="keyword">if</span>(place(x, t))</span><br><span class="line">            &#123;</span><br><span class="line">                nQueensRec(x, t + <span class="number">1</span>, N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保存皇后的位置</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">9</span>];</span><br><span class="line">    nQueensRec(x, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-98</title>
    <url>/2020/07/04/leetcode-98/</url>
    <content><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>
<p>输入:<br>    2<br>   / <br>  1   3<br>输出: true<br>示例 2:</p>
<p>输入:<br>    5<br>   / <br>  1   4<br>     / <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题一开始我想的是使用二叉树的中序遍历法，如果对一棵二叉树进行中序遍历，那么遍历的结果一定是递增的，如果不满足那么就不是二叉树。</p>
<h3 id="法一：中序遍历"><a href="#法一：中序遍历" class="headerlink" title="法一：中序遍历"></a>法一：中序遍历</h3><p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Travelsal(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) &gt;= list.get(i + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Travelsal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Travelsal(root.left);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            Travelsal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：递归"><a href="#法二：递归" class="headerlink" title="法二：递归"></a>法二：递归</h3><p>又来递归了，什么时候才能自己搞出完整的递归思路以及代码。</p>
<p>这道题我后来是看出点端倪的，也就是要取判断结点值的范围，但是不会整理思路。</p>
<p>递归难就难在要找问题的共同点，以及怎么样去递进。这道题递归的思路是取出当前节点的值接着判断这个结点的范围是否在左子树的值与右子树的值之间。那么很明显的范围是随时要改变的，所以要作为函数的参数。</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur_val = node.val;</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; cur_val &lt;= lower) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; cur_val &gt;= upper) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!helper(node.left, lower, cur_val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!helper(node.right, cur_val, upper)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-探索初级算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子段和问题</title>
    <url>/2020/04/21/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="最大子段和问题"><a href="#最大子段和问题" class="headerlink" title="最大子段和问题"></a>最大子段和问题</h1><h2 id="递归关系分析"><a href="#递归关系分析" class="headerlink" title="递归关系分析"></a>递归关系分析</h2><p>首先定义 b[j] 表示 i 从 1 变到 j 时每个a[i]+a[i+1]+…+a[j] 比较的最大值，<br>那么数组 b[j], 1 &lt;= j &lt;= n的最大值即为a数组的最大字段和  </p>
<p>根据b[j]的定义，我们有:<br><strong>b[j-1] &gt; 0时, b[j] = b[j-1] + a[j]<br>否则 b[j] = a[j]</strong></p>
<p>由此有b[j]的动态规划递推式:<br><strong>1 &lt;= j &lt;= n 时, b[j] = max{b[j-1] + a[j], a[j]}</strong></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 101</span></span><br><span class="line"><span class="keyword">int</span> a[NUM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxsum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; <span class="number">0</span>) b += a[i];</span><br><span class="line">        <span class="keyword">else</span> b = a[i];</span><br><span class="line">        <span class="keyword">if</span>(b &gt; sum) sum = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2020/05/27/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表的概念"><a href="#哈希表的概念" class="headerlink" title="哈希表的概念"></a>哈希表的概念</h1><p><strong>哈希表</strong>(hash table) 又称散列表，其基本思路是，设要存储的元素个数为 n, 设置一个长度为 m(m &gt;= n) 的连续内存单元，以每个元素的关键字 ki ( 0 &lt;= i &lt;= n - 1) 为自变量 ，通过一个称为 <strong>哈希函数</strong>(hash function) 的函数 h(ki) 把 ki 映射为内存单元的地址（或下标） h(ki), 并把该元素存储在这个内存单元中。h (ki) 也称为 <strong>哈希地址</strong> (hash address)。把如此构造的线性表存储结构称为哈希表。</p>
<p>在构建哈希表时可能存在这样的问题，两个关键字 ki和 kj(i != j)有 ki != kj ，但会出现 h(ki) = h(kj) 的情况，把这种现象叫<strong>哈希冲突</strong> (hash collisions) 。 通常把这种具有不同关键字而具有相同哈希地址的元素称为同义词 (synonym), 这种冲突也称为同义词冲突 。 在哈希表存储结构中，同义词冲突是很难避免的，除非关键字的变化区间小于等于哈希地址的变化区间，而这种情况当关键字取值不连续时是非常浪费存储空间的。通常的实际情况是关键字的取值区间远大于哈希地址的变化区间 。</p>
<p>归纳起来，当<strong>一组数据的关键字与存储地址存在某种映射关系</strong>时，这组数据适合于采用哈希表存储。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾汇编</title>
    <url>/2020/05/06/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h1><p>32位CPU所含有的寄存器有：<br>4个数据寄存器(EAX、EBX、ECX和EDX)<br>2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)<br>6个段寄存器(ES、CS、SS、DS、FS和GS)<br>1个指令指针寄存器(EIP) 1个标志寄存器(EFlags)</p>
<h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p>数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。<br>32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。<br>对低16位数据的存取，不会影响高16位的数据。<br>这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。<br>4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。<br>程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。</p>
<p>寄存器EAX通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。可用于乘、 除、输入/输出等操作，使用频率很高；<br>寄存器EBX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；<br>寄存器ECX称为计数寄存器(Count Register)。<br>在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；<br>寄存器EDX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。</p>
<p>在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，<br>在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，<br>而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。</p>
<h2 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h2><p>32位CPU有2个32位通用寄存器ESI和EDI。<br>其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。</p>
<p>寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，<br>用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。<br>变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。<br>它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p>
<h2 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h2><p>其低16位对应先前CPU中的BP和SP，对低16位数据的存取，不影响高16位的数据。<br>32位CPU有2个32位通用寄存器EBP和ESP。<br>它们主要用于访问堆栈内的存储单元，并且规定：<br>EBP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；<br>ESP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。</p>
<p>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，<br>用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。<br>指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成<br>的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。<br>CPU内部的段寄存器：</p>
<p>ECS——代码段寄存器(Code Segment Register)，其值为代码段的段值；<br>EDS——数据段寄存器(Data Segment Register)，其值为数据段的段值；<br>EES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>ESS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；<br>EFS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>EGS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。</p>
<p>在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位<br>微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。</p>
<p>32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简<br>单描述如下：</p>
<p>实方式： 前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑<br>地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。<br>保护方式： 在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”(Selector)的某个值。。</p>
<h2 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h2><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。</p>
<p>指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。<br>在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。<br>所以，在理解它们的功能时，不考虑存在指令队列的情况。</p>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><h3 id="运算结果标志位"><a href="#运算结果标志位" class="headerlink" title="运算结果标志位"></a>运算结果标志位</h3><h4 id="进位标志CF-Carry-Flag"><a href="#进位标志CF-Carry-Flag" class="headerlink" title="进位标志CF(Carry Flag)"></a>进位标志CF(Carry Flag)</h4><p>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。<br>使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。</p>
<h4 id="奇偶标志PF-Parity-Flag"><a href="#奇偶标志PF-Parity-Flag" class="headerlink" title="奇偶标志PF(Parity Flag)"></a>奇偶标志PF(Parity Flag)</h4><p>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br>利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。</p>
<h4 id="辅助进位标志AF-Auxiliary-Carry-Flag"><a href="#辅助进位标志AF-Auxiliary-Carry-Flag" class="headerlink" title="辅助进位标志AF(Auxiliary Carry Flag)"></a>辅助进位标志AF(Auxiliary Carry Flag)</h4><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：</p>
<p>(1)、在字操作时，发生低字节向高字节进位或借位时；<br>(2)、在字节操作时，发生低4位向高4位进位或借位时。<br>对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。</p>
<h4 id="零标志ZF-Zero-Flag"><a href="#零标志ZF-Zero-Flag" class="headerlink" title="零标志ZF(Zero Flag)"></a>零标志ZF(Zero Flag)</h4><p>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</p>
<h4 id="符号标志SF-Sign-Flag"><a href="#符号标志SF-Sign-Flag" class="headerlink" title="符号标志SF(Sign Flag)"></a>符号标志SF(Sign Flag)</h4><p>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。</p>
<h4 id="溢出标志OF-Overflow-Flag"><a href="#溢出标志OF-Overflow-Flag" class="headerlink" title="溢出标志OF(Overflow Flag)"></a>溢出标志OF(Overflow Flag)</h4><p>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p>
<p>“溢出”和“进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。</p>
<h3 id="状态控制标志位"><a href="#状态控制标志位" class="headerlink" title="状态控制标志位"></a>状态控制标志位</h3><p>状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。</p>
<h4 id="追踪标志TF-Trap-Flag"><a href="#追踪标志TF-Trap-Flag" class="headerlink" title="追踪标志TF(Trap Flag)"></a>追踪标志TF(Trap Flag)</h4><p>当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。</p>
<p>指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。</p>
<h4 id="中断允许标志IF-Interrupt-enable-Flag"><a href="#中断允许标志IF-Interrupt-enable-Flag" class="headerlink" title="中断允许标志IF(Interrupt-enable Flag)"></a>中断允许标志IF(Interrupt-enable Flag)</h4><p>中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。<br>但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。<br>具体规定如下：<br>(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>CPU的指令系统中也有专门的指令来改变标志位IF的值。</p>
<h4 id="方向标志DF-Direction-Flag"><a href="#方向标志DF-Direction-Flag" class="headerlink" title="方向标志DF(Direction Flag)"></a>方向标志DF(Direction Flag)</h4><p>方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。<br>在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。</p>
<h3 id="32位标志寄存器增加的标志位"><a href="#32位标志寄存器增加的标志位" class="headerlink" title="32位标志寄存器增加的标志位"></a>32位标志寄存器增加的标志位</h3><h4 id="I-O特权标志IOPL-I-O-Privilege-Level"><a href="#I-O特权标志IOPL-I-O-Privilege-Level" class="headerlink" title="I/O特权标志IOPL(I/O Privilege Level)"></a>I/O特权标志IOPL(I/O Privilege Level)</h4><p>I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。<br>如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。</p>
<h4 id="嵌套任务标志NT-Nested-Task"><a href="#嵌套任务标志NT-Nested-Task" class="headerlink" title="嵌套任务标志NT(Nested Task)"></a>嵌套任务标志NT(Nested Task)</h4><p>嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：</p>
<p>(1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；</p>
<p>(2)、当NT=1，通过任务转换实现中断返回。</p>
<h4 id="重启动标志RF-Restart-Flag"><a href="#重启动标志RF-Restart-Flag" class="headerlink" title="重启动标志RF(Restart Flag)"></a>重启动标志RF(Restart Flag)</h4><p>重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。<br>在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。</p>
<h4 id="虚拟8086方式标志VM-Virtual-8086-Mode"><a href="#虚拟8086方式标志VM-Virtual-8086-Mode" class="headerlink" title="虚拟8086方式标志VM(Virtual 8086 Mode)"></a>虚拟8086方式标志VM(Virtual 8086 Mode)</h4><p>如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。</p>
<h1 id="汇编指令集合"><a href="#汇编指令集合" class="headerlink" title="汇编指令集合"></a>汇编指令集合</h1><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令."></a>通用数据传送指令.</h3><p>MOV 传送字或字节.<br>MOVSX 先符号扩展,再传送.<br>MOVZX 先零扩展,再传送.<br>PUSH 把字压入堆栈.<br>POP 把字弹出堆栈.<br>PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.<br>POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.<br>PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.<br>POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.<br>BSWAP 交换32位寄存器里字节的顺序<br>XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)<br>CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )<br>XADD 先交换再累加.( 结果在第一个操作数里 )<br>XLAT 字节查表转换.<br>BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</p>
<h3 id="输入输出端口传送指令"><a href="#输入输出端口传送指令" class="headerlink" title="输入输出端口传送指令."></a>输入输出端口传送指令.</h3><p>IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )<br>OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )<br>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535.</p>
<h3 id="目的地址传送指令"><a href="#目的地址传送指令" class="headerlink" title="目的地址传送指令."></a>目的地址传送指令.</h3><p>LEA 装入有效地址.<br>例: LEA DX,string ;把偏移地址存到DX.<br>LDS 传送目标指针,把指针内容装入DS.<br>例: LDS SI,string ;把段地址:偏移地址存到DS:SI.<br>LES 传送目标指针,把指针内容装入ES.<br>例: LES DI,string ;把段地址:偏移地址存到ESDI.<br>LFS 传送目标指针,把指针内容装入FS.<br>例: LFS DI,string ;把段地址:偏移地址存到FSD.<br>LGS 传送目标指针,把指针内容装入GS.<br>例: LGS DI,string ;把段地址:偏移地址存到GSDI.<br>LSS 传送目标指针,把指针内容装入SS.<br>例: LSS DI,string ;把段地址:偏移地址存到SSDI.</p>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令."></a>标志传送指令.</h3><p>LAHF 标志寄存器传送,把标志装入AH.<br>SAHF 标志寄存器传送,把AH内容装入标志寄存器.<br>PUSHF 标志入栈.<br>POPF 标志出栈.<br>PUSHD 32位标志入栈.<br>POPD 32位标志出栈.</p>
<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><p>ADD 加法.<br>ADC 带进位加法.<br>INC 加 1.<br>AAA 加法的ASCII码调整.<br>DAA 加法的十进制调整.<br>SUB 减法.<br>SBB 带借位减法.<br>DEC 减 1.<br>NEC 求反(以 0 减之).<br>CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).<br>AAS 减法的ASCII码调整.<br>DAS 减法的十进制调整.<br>MUL 无符号乘法.<br>IMUL 整数乘法.</p>
<p>以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),<br>AAM 乘法的ASCII码调整.<br>DIV 无符号除法.<br>IDIV 整数除法.<br>以上两条,结果回送:<br>商回送AL,余数回送AH, (字节运算);<br>或 商回送AX,余数回送DX, (字运算).</p>
<p>AAD 除法的ASCII码调整.<br>CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)<br>CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)<br>CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)<br>CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p>
<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><p>AND 与运算.<br>OR 或运算.<br>XOR 异或运算.<br>NOT 取反.<br>TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).<br>SHL 逻辑左移.<br>SAL 算术左移.(=SHL)<br>SHR 逻辑右移.<br>SAR 算术右移.(=SHR)<br>ROL 循环左移.<br>ROR 循环右移.<br>RCL 通过进位的循环左移.<br>RCR 通过进位的循环右移.<br>以上八种移位指令,其移位次数可达255次.<br>移位一次时, 可直接用操作码. 如 SHL AX,1.<br>移位&gt;1次时, 则由寄存器CL给出移位次数.<br>如 MOV CL,04<br>SHL AX,CL</p>
<h2 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h2><p>DS:SI 源串段寄存器 :源串变址.<br>ES I 目标串段寄存器:目标串变址.<br>CX 重复次数计数器.<br>AL/AX 扫描值.<br>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.</p>
<p>Z标志 用来控制扫描或比较操作的结束.<br>MOVS 串传送.<br>( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )<br>CMPS 串比较.<br>( CMPSB 比较字符. CMPSW 比较字. )<br>SCAS 串扫描.<br>把AL或AX的内容与目标串作比较,比较结果反映在标志位.<br>LODS 装入串.<br>把源串中的元素(字或字节)逐一装入AL或AX中.<br>( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )<br>STOS 保存串.<br>是LODS的逆过程.<br>REP 当CX/ECX&lt;&gt;0时重复.<br>REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.<br>REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.<br>REPC 当CF=1且CX/ECX&lt;&gt;0时重复.<br>REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.</p>
<h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><h3 id="简单的条件转移指令"><a href="#简单的条件转移指令" class="headerlink" title="简单的条件转移指令"></a>简单的条件转移指令</h3><p>JZ(或jE) OPR—————结果为零转移, 测试条件ZF=1<br>JNZ(或jNE) OPR ————–结果不为零转移,测试条件ZF=0<br>JS OPR———————-结果为负转移, 测试条件SF=1<br>JNS OPR———————结果为正转移, 测试条件SF=0<br>JO OPR——————— 溢出转移, 测试条件OF=<br>JNO OPR ——————–不溢出转移 , 测试条件SF=0<br>JP OPR ———————结果为偶转移, 测试条件SF=1<br>JNP OPR ——————–结果为奇转移 , 测试条件SF=0<br>JC OPR ——————– 有进位转移 , 测试条件SF=1<br>JNC OPR ——————–无进位转移, 测试条件SF=0</p>
<h3 id="无符号比较条件转移指令-以下指令经常是CMP-OPD-OPS后面的指令根据比较结果来实现转移"><a href="#无符号比较条件转移指令-以下指令经常是CMP-OPD-OPS后面的指令根据比较结果来实现转移" class="headerlink" title="无符号比较条件转移指令(以下指令经常是CMP OPD,OPS后面的指令根据比较结果来实现转移)"></a>无符号比较条件转移指令(以下指令经常是CMP OPD,OPS后面的指令根据比较结果来实现转移)</h3><p>JB(或JNAE) opd ————–小于或者不大于等于则转移<br>JNB(或JAE) opd—————不小于或者大于等于则转移<br>JA(或NJBE) OPD—————大于或者不小于等于则转移<br>JNA(或JBE) OPD—————不大于或者小于等于则转移</p>
<h3 id="带符号比较条件转移指令"><a href="#带符号比较条件转移指令" class="headerlink" title="带符号比较条件转移指令"></a>带符号比较条件转移指令</h3><p>JL(或JNGE) ————–小于或者不大于等于则转移<br>JNL(或JGE)————–不小于或者大于等于则转移<br>JG(或NJLE)—————大于或者不小于等于则转移<br>JNG(或JLE)—————不大于或者小于等于则转移</p>
<h2 id="调用子程序与返回指令"><a href="#调用子程序与返回指令" class="headerlink" title="调用子程序与返回指令"></a>调用子程序与返回指令</h2><p>CALL 子程序调用指令<br>RET 子程序返回指令</p>
<h2 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h2><p>OFFSET ——————– 返回偏移地址<br>SEG ——————– 返回段地址<br>EQU(=) ——————– 等值语句<br>PURGE ——————– 解除语句<br>DUP ——————– 操作数字段用复制操作符<br>SEGMENT,ENDS ——————– 段定义指令<br>ASSUME ——————– 段地址分配指令<br>ORG ——————– 起始偏移地址设置指令<br>$ ——————–地址计数器的当前值<br>PROC，ENDP ——————– 过程定义语句<br>NAME，TITLE，END ——————– 程序开始结束语句<br>MACRO，ENDM ——————–宏定义指令<br>XLAT （TRANSLATE） ——————– 换码指令—-</p>
<h2 id="条件标志"><a href="#条件标志" class="headerlink" title="条件标志"></a>条件标志</h2><p>ZF 零标志 – 当结果为负时,SF=1,否则,SF=0.<br>AF 辅助进位标志—运算过程中第三位有进位值,置AF=1,否则,AF=0<br>PF 奇偶标志——当结果操作数中偶数个”1”,置PF=1,否则,PF=0<br>SF 符号标志—-当结果为负时,SF=1;否则,SF=0.溢出时情形例外<br>CF 进位标志—– 最高有效位产生进位值,例如,执行加法指令时,MSB有进位,置CF=1;否则,CF=0.<br>OF 溢出标志—–若操作数结果超出了机器能表示的范围,则产生溢出,置OF=1,否则,OF=0</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵连乘优化</title>
    <url>/2020/04/21/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="矩阵连乘优化问题"><a href="#矩阵连乘优化问题" class="headerlink" title="矩阵连乘优化问题"></a>矩阵连乘优化问题</h1><h2 id="穷举法的问题"><a href="#穷举法的问题" class="headerlink" title="穷举法的问题"></a>穷举法的问题</h2><p>穷举法即找出每一种完全加括号方式相应需要的数乘次数    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设n &#x3D; 1时，p(n) &#x3D; 1</span><br><span class="line">n &gt;&#x3D; 2时，p(n) &#x3D; p(1) * p(n-1) + p(2) * p(n-2) + ... + p(n-1) * p(1)</span><br><span class="line">p(n)实际为catalan数</span><br><span class="line">p(n) &#x3D; C(n-1) 其中C(n) &#x3D; 1*(2n n)&#x2F;(n+1)     (2n n)表示从2n个元素中选出n个元素的组合数</span><br></pre></td></tr></table></figure>
<p>时间复杂度呈指数级增长，不推荐。</p>
<h2 id="采用动态规划法进行优化"><a href="#采用动态规划法进行优化" class="headerlink" title="采用动态规划法进行优化"></a>采用动态规划法进行优化</h2><h3 id="1，分析最优子结构特性"><a href="#1，分析最优子结构特性" class="headerlink" title="1，分析最优子结构特性"></a>1，分析最优子结构特性</h3><h3 id="2，建立递归关系"><a href="#2，建立递归关系" class="headerlink" title="2，建立递归关系"></a>2，建立递归关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义计算A[i][j]所需要的最优次数为m[i][j],p[]数组存放矩阵的维数，因为矩阵可乘必有相邻矩阵行列相等，因此用p[i-1],p[i]来表示每个矩阵Ai的维数。</span><br><span class="line">i &#x3D; j, m[i][j] &#x3D; 0</span><br><span class="line">i &lt; j, m[i][j] &#x3D; min&#123;m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]&#125; (i &lt;&#x3D; k &lt; j)</span><br></pre></td></tr></table></figure>
<h3 id="3，计算最优值"><a href="#3，计算最优值" class="headerlink" title="3，计算最优值"></a>3，计算最优值</h3><h3 id="4，构造最优解"><a href="#4，构造最优解" class="headerlink" title="4，构造最优解"></a>4，构造最优解</h3><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//矩阵连乘动态规划算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> **p, <span class="keyword">int</span> **m, <span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将对角线置为零，即矩阵自身数乘次数为零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组的上斜对角线数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">2</span>； r &lt;= n; r++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//每个斜对角线的行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//每个斜对角线的列</span></span><br><span class="line">         <span class="keyword">int</span> j = i + r - <span class="number">1</span>;</span><br><span class="line">         <span class="comment">//计算初值，便于比较并替换最小值</span></span><br><span class="line">         m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];</span><br><span class="line">         <span class="comment">//s[i][j]用来保存断点</span></span><br><span class="line">         s[i][j] = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">               m[i][j] = t;</span><br><span class="line">               s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归构造最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>;</span><br><span class="line">    traceBack(i, s[i][j], s);</span><br><span class="line">    traceBack(s[i][j] + <span class="number">1</span>, j, s);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态机</title>
    <url>/2020/07/01/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="有限状态机的简单介绍"><a href="#有限状态机的简单介绍" class="headerlink" title="有限状态机的简单介绍"></a>有限状态机的简单介绍</h2><p>有限状态机将一个对象的行为分解为容易处理的“块”或者状态，对象执行了某些变换对象将从一个状态变成了另一种状态，说的简单点就是状态流程图，然后这些状态的数量是有限的。</p>
<p>举个例子说明吧：</p>
<p>假如我们现在正在开发一款横版游戏。当前的任务是实现玩家用按键操纵女英雄。当按下向上方向键的时候，女英雄应该跳跃。那么我们可以这样实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Heroine::handleInput(Input input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_UP)</span><br><span class="line">    &#123;</span><br><span class="line">        yVelocity_ = JUMP_VELOCITY;</span><br><span class="line">        setGraphics(IMAGE_JUMP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，实现是实现了，但是一堆BUG。比如，我们没有防止主角“在空中跳跃“，当主角跳起来后持续按向上键，会导致她一直飘在空中。简单地修复方法可以是：添加一个 isJumping布尔值变量。当主角跳起来后，就把该变量设置为True.只有当该变量为False时，才让主角跳跃，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Heroine::handleInput(Input input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (input == PRESS_UP)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isJumping_)</span><br><span class="line">    &#123;</span><br><span class="line">      isJumping_ = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// Jump...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们想实现主角的闪避动作。当主角站在地面上的时候，如果玩家按下向下方向键，则下蹲躲避，如果松开此键，则起立。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Heroine::handleInput(Input input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_UP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Jump if not jumping...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (input == PRESS_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isJumping_)</span><br><span class="line">        &#123;</span><br><span class="line">            setGraphics(IMAGE_DUCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (input == RELEASE_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        setGraphics(IMAGE_STAND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找找看， 这次bug又在哪里？</p>
<p>使用这段代码，玩家可以：按向下键下蹲，按向上键则从下蹲状态跳起，英雄会在跳跃的半路上变成站立图片…….是时候增加另一个标识了……</p>
<p>那么为什么会出现需要反复添加标记变量的问题呢，对于那些标记也可以看做一个个的状态啊，原因是上述代码执行逻辑的出发点是操作而非状态，可以用如下图表示：</p>
<img src="/2020/07/01/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/auto_1.png" class title="状态图1">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用下面的代码详细说明下吧。</span><br><span class="line"><span class="keyword">void</span> Heroine::handleInput(Input input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (input == PRESS_UP)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isJumping_)</span><br><span class="line">    &#123;</span><br><span class="line">      isJumping_ = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// Jump...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先判断的不是状态，是操作，也就是if( input == PRESS_UP ),这样直接导致的后果是你需要在后面的代码中判断角色之前处于什么状态，然后将状态转换到相应的另一种状态。并且从上面的图也可以看到，这种方式不可能将任意多个状态串联到一起的，当按下向上的按钮后，再按下向下的按钮这是是两个独立的分析判断。</p>
<p>而采用有限状态机时，由于判断的出发点是状态，我们只需要关注于当前处理的状态，这样可以将整个逻辑串联成一个整体，也就是一个流程。比如起始状态是状态A，由于已经知道了当前的状态，此时如果知道操作是什么那么从状态流程图上就知道下一个状态是什么，因为一个状态执行一个操作后只能到达的状态只能是其中一种。</p>
<p>比如下图：从状态D如果执行某一种变换，它只可能到达状态B或者状态E，而不可能即处于状态B又处于状态E。</p>
<img src="/2020/07/01/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/auto_2.png" class title="状态图2">

<p>对有限状态机的介绍先到这里。</p>
<p>那么问题来了，FSM限制了同时只能存在一种状态,那么如果角色既被冰住了又晕了怎么办？<br>还有并发状态机，多层次状态机。后续学习吧。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有限状态机</tag>
      </tags>
  </entry>
</search>
