<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>矩阵连乘优化</title>
    <url>/2020/04/21/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="矩阵连乘优化问题"><a href="#矩阵连乘优化问题" class="headerlink" title="矩阵连乘优化问题"></a>矩阵连乘优化问题</h1><h2 id="穷举法的问题"><a href="#穷举法的问题" class="headerlink" title="穷举法的问题"></a>穷举法的问题</h2><p>穷举法即找出每一种完全加括号方式相应需要的数乘次数    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设n &#x3D; 1时，p(n) &#x3D; 1</span><br><span class="line">n &gt;&#x3D; 2时，p(n) &#x3D; p(1) * p(n-1) + p(2) * p(n-2) + ... + p(n-1) * p(1)</span><br><span class="line">p(n)实际为catalan数</span><br><span class="line">p(n) &#x3D; C(n-1) 其中C(n) &#x3D; 1*(2n n)&#x2F;(n+1)     (2n n)表示从2n个元素中选出n个元素的组合数</span><br></pre></td></tr></table></figure>
<p>时间复杂度呈指数级增长，不推荐。</p>
<h2 id="采用动态规划法进行优化"><a href="#采用动态规划法进行优化" class="headerlink" title="采用动态规划法进行优化"></a>采用动态规划法进行优化</h2><h3 id="1，分析最优子结构特性"><a href="#1，分析最优子结构特性" class="headerlink" title="1，分析最优子结构特性"></a>1，分析最优子结构特性</h3><h3 id="2，建立递归关系"><a href="#2，建立递归关系" class="headerlink" title="2，建立递归关系"></a>2，建立递归关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义计算A[i][j]所需要的最优次数为m[i][j],p[]数组存放矩阵的维数，因为矩阵可乘必有相邻矩阵行列相等，因此用p[i-1],p[i]来表示每个矩阵Ai的维数。</span><br><span class="line">i &#x3D; j, m[i][j] &#x3D; 0</span><br><span class="line">i &lt; j, m[i][j] &#x3D; min&#123;m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]&#125; (i &lt;&#x3D; k &lt; j)</span><br></pre></td></tr></table></figure>
<h3 id="3，计算最优值"><a href="#3，计算最优值" class="headerlink" title="3，计算最优值"></a>3，计算最优值</h3><h3 id="4，构造最优解"><a href="#4，构造最优解" class="headerlink" title="4，构造最优解"></a>4，构造最优解</h3><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//矩阵连乘动态规划算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> **p, <span class="keyword">int</span> **m, <span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将对角线置为零，即矩阵自身数乘次数为零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组的上斜对角线数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">2</span>； r &lt;= n; r++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//每个斜对角线的行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//每个斜对角线的列</span></span><br><span class="line">         <span class="keyword">int</span> j = i + r - <span class="number">1</span>;</span><br><span class="line">         <span class="comment">//计算初值，便于比较并替换最小值</span></span><br><span class="line">         m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];</span><br><span class="line">         <span class="comment">//s[i][j]用来保存断点</span></span><br><span class="line">         s[i][j] = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">               m[i][j] = t;</span><br><span class="line">               s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归构造最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>;</span><br><span class="line">    traceBack(i, s[i][j], s);</span><br><span class="line">    traceBack(s[i][j] + <span class="number">1</span>, j, s);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
